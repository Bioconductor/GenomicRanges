%\VignetteIndexEntry{Counting Alignment Overlaps with GenomicRanges}
%\VignetteDepends{}
%\VignetteKeywords{sequence, sequencing, alignments}
%\VignettePackage{GenomicRanges}
\documentclass[10pt]{article}

\usepackage{times}
\usepackage{hyperref}

\newcommand{\Rfunction}[1]{{\texttt{#1}}}
\newcommand{\Robject}[1]{{\texttt{#1}}}
\newcommand{\Rpackage}[1]{{\textit{#1}}}
\newcommand{\Rmethod}[1]{{\texttt{#1}}}
\newcommand{\Rfunarg}[1]{{\texttt{#1}}}
\newcommand{\Rclass}[1]{{\textit{#1}}}
\newcommand{\Rcode}[1]{{\texttt{#1}}}

\newcommand{\software}[1]{\textsf{#1}}
\newcommand{\R}{\software{R}}
\newcommand{\Bioconductor}{\software{Bioconductor}}
\newcommand{\GenomicRanges}{\Rpackage{GenomicRanges}}

\SweaveOpts{keep.source=TRUE}

\title{Approaches to Counting Alignment Overlaps with \GenomicRanges{}}
\author{Martin Morgan}
\date{Edited: 27 December 2010; Compiled: \today}

\begin{document} 

\maketitle

This vignette outlines one approach to counting short sequence reads
aligned to a reference genome. The vignette illustrates some common
use cases; other components of the work flow are documented in the
help pages of functions referenced below, or in other vignettes in
this (\Rpackage{GenomicRanges} and related (e.g.,
\Rpackage{GenomicFeatures}, \Rpackage{rtracklayer},
\Rpackage{IRanges}, \Rpackage{Rsamtools}) packages.

\section{Data}
For test cases, we create a \Rpackage{GRangesList} of regions of
interest (\Robject{subj}) and reads (\Robject{query}), e.g., using a
short helper function \Rfunction{rng}
%% 
<<data>>=
library(GenomicFeatures)

rng <- function(s, w)
    ## ranges by 'start', 'width'; same chromosome, strand
    GRanges(seq="chr1", IRanges(s, width=w), strand="+")

subj <- GRangesList(A=rng(1000, 900),
                    B=rng(2000, 900),
                    C=rng(c(3000, 3600), c(500, 300)),
                    D=rng(c(4000, 4600), c(500, 300)),
                    E1=rng(5000, 700), E2=rng(5500, 400),
                    F1=rng(6000, 700), F2=rng(6500, 400),
                    G1=rng(7000, 700), G2=rng(7500, 400))

query <- GRangesList(a=rng(1500, 100),
                     b=rng(2850, 100),
                     c=rng(3450, 200),
                     d=rng(c(4400, 4600), 100),
                     e=rng(5100, 100),
                     f=rng(6450, 100),
                     g=rng(7600, 100))
@ 
%% 
\Robject{subj} genes C and D have two exons; pairs of genes E1, E2,
and F1, F2, and G1, G2 overlap. \Robject{query} d is aligned with a
gap.

Normally one might create \Robject{subj} with
\Rfunction{makeTranscriptDbFromUCSC}, \Rfunction{import} (for
GFF-like) or other \Rpackage{rtracklayer} functionality, or from
queries to \Rpackage{biomaRt} or using the \Rpackage{AnnotationDbi},
\Rpackage{*org}, and \Rpackage{BSgenome*} \Bioconductor{} annotation
packages. \Robject{query} might normally come from BAM files (e.g.,
\Rfunction{readGappedAlignements} in \Rpackage{GenomicRanges} or
\Rfunction{scanBam} in \Rpackage{Rsamtools}) or other aligned reads
(using base \R{} functionality for pure text files, or perhaps
\Rfunction{readAligned} from \Rpackage{ShortRead}, if the alignments
do not contain gaps). These operations are described in the vignettes
of the corresponding packages.

\section{Counting schemes}

\subsection{Unique hit union}

In this scheme, we count the number of times each read
(\Robject{query}) overlaps a region of interest (\Robject{subj}), then
drop those reads with more than one hit and count the number of times
each subject overlaps a (now unambiguous) read
%% 
<<union>>=
hitsPerQuery <- countOverlaps(query, subj)
countOverlaps(subj, query[hitsPerQuery == 1])
@ 

\subsection{Strict intersection}

This scheme counts queries that lie strictly within regions of
interest. The within-region functionality is not currently available
with \Rclass{GRangesList} objects, so we create a helper function to coerce
our data to a \Rclass{RangesList}, and to create an index that maps in the
reverse direction
%% 
<<grl-helper>>=
grl2rl <- function(x)
    ## coerce GRangesList to RangesList
    as(unlist(x, use.names=FALSE), "RangesList")
maprl <- function(x)
    ## map to 'x' GRangesList indicies from RangesList
    rep(seq_len(length(x)), elementLengths(x))
@ 

We will also need a helper function to take overlaps found on the
\Rclass{RangesList} objects and map them to \Rclass{GRangesList},
taking into account the query (\Robject{qmap}) and subject
(\Robject{smap}) maps. We also use the opportunity to remove queries
that hit multiple subjects
%% 
<<recount>>=
recount <-
    function(olap, qmap, smap)
    ## re-map to GRangesList, removing multi-hit queries
{
    ## re-map hits
    q_hits <- qmap[queryHits(olap)]
    s_hits <- smap[subjectHits(olap)]
    ## remove queries that align to multiple subjects
    hitmap0 <- lapply(split(s_hits, q_hits), unique)
    hitmap <- Filter(function(x) length(x) == 1, hitmap0)
    ## return as vector of counts
    tabulate(as.integer(hitmap), max(smap))
}
@ 
%% 
We count with
%% 
<<strict-intersect>>=
olaps <-
    findOverlaps(grl2rl(query), grl2rl(subj), type="within")
lapply(olaps, recount, maprl(query), maprl(subj))
@ 

\Rfunction{grl2rl} loses strand information. This will be appropriate
for some RNAseq protocols; if not, then the two lines above can be
repeated for appropriate strand subsets of \Robject{query},
\Robject{subj}.  Interesting exercises would modify
\Rfunction{recount} to, say, use in the `uniqe union' approach to divide
queries amongst the regions they overlap (rather than discarding) or
to return counts-per-exon rather than summarizing to the original gene
level.

\subsection{Non-empty intersection}

The goal is to count reads that overlap, by any number of nucleotides,
any single subject. To do this we write a helper to coerce a
\Rclass{GRangesList} to disjoint regions that are represented exactly once,
i.e., discarding subject regions overlapping one another.

<<grl2udrl>>=
grl2udrl <- function(x)
    ## GRangesList to unique disjoint RangesList
{
    rl <- unlist(x)
    d <- disjoin(rl)
    ud <- d[countOverlaps(d, rl) == 1]
    as(ud, "RangesList")
}
mapudrl <- function(x)
    ## map to 'x'  GRangesList from u. d. RangesList
    subjectHits(findOverlaps(grl2udrl(x), x))
@ 
%% 
and then we count
%% 
<<non-empty-intersection>>=
olaps <- findOverlaps(grl2rl(query), grl2udrl(subj))
lapply(olaps, recount, maprl(query), mapudrl(subj))
@ 

\end{document}
