%\VignetteIndexEntry{Overview of countFeatureHits}
%\VignetteDepends{}
%\VignetteKeywords{sequence, sequencing, alignments}
%\VignettePackage{GenomicRanges}
\documentclass[10pt]{article}

\usepackage{times}
\usepackage{hyperref}

\newcommand{\Rfunction}[1]{{\texttt{#1}}}
\newcommand{\Robject}[1]{{\texttt{#1}}}
\newcommand{\Rpackage}[1]{{\textit{#1}}}
\newcommand{\Rmethod}[1]{{\texttt{#1}}}
\newcommand{\Rfunarg}[1]{{\texttt{#1}}}
\newcommand{\Rclass}[1]{{\textit{#1}}}
\newcommand{\Rcode}[1]{{\texttt{#1}}}

\newcommand{\software}[1]{\textsf{#1}}
\newcommand{\R}{\software{R}}
\newcommand{\Bioconductor}{\software{Bioconductor}}
\newcommand{\GenomicRanges}{\Rpackage{GenomicRanges}}

\SweaveOpts{keep.source=TRUE}

\title{Overview of \Rfunction{countFeatureHits}}
\author{Valerie Obenchain}
\date{Edited: 18 September 2011; Compiled: \today}

\begin{document}

\maketitle

\section{Introduction}
This vignette illustrates how reads mapped to a genome
can be counted with \Rfunction{countFeatureHits}. Different "modes" of
counting are provided to resolve reads that overlap multiple features.
The built-in count modes are patterned after the "Union", "IntersectionStrict",
and "IntersectionNotEmpty" methods found in the HTSeq package by Simon
Anders (see references). Alternatively, the user can provide their own count 
function and make use of the \Rfunction{countFeatureHits} infrastructure for 
reading multiple BAM files and parsing results into a 
\Robject{SummarizedExperiment} object.


\section{A First Example}

In this example reads are counted from a list of BAM files and returned in
a \Rcode{data.frame} for use in further analysis such as those 
offered in \Rpackage{edgeR} and \Rpackage{DESeq}. 

<<firstExample, eval=FALSE, keep.source=TRUE>>=
library(TxDb.Hsapiens.UCSC.hg18.knownGene)
txdb <- Hsapiens_UCSC_hg18_knownGene_TxDb
ranges <- exonsBy(txdb, "tx")
bamFiles <- c("sample1.bam", "sample2.bam")

countsTable <-
    as.data.frame(tx_id=rep(names(ranges), elementLengths(ranges)),
                  exon_id=values(unlist(ranges))[["exon_id"]],
                  assays(countFeatureHits(bamFiles, ranges))$counts
                  )
@

\begin{verbatim}
> head(countsTable)
  tx_id exon_id sample1.bam sample2.bam
1     1       1           0           0
2     1       2           5           2
3     1       3           3           0
4     2       1           0           0
5     2       4          28          32
6     3       8           1           4
\end{verbatim}


\section{Counting Modes}

The modes of "Union", "IntersectionStrict" and "IntersectionNotEmpty" 
provide different approaches to resolving reads that overlap multiple 
features. Figure~\ref{fig-countFeatureHits-modes} illustrates how both simple and 
gapped reads are handled by the modes. Note that a read is counted a
maximum of once; there is no double counting. These methods do not 
currently handle paired-end reads.

\begin{figure}[!h]
\begin{center}
\includegraphics{countFeatureHits-modes.pdf}
\caption{Counting Modes}
\label{fig-countFeatureHits-modes}
\end{center}
\end{figure}

\newpage

\section{Counting}

\Rfunction{countFeatureHits} counts reads mapped to features on a
genome where the features can be exons, transcripts, genes or 
any other region of interest. 

When a \Robject{GRanges} is supplied as the \Robject{features}
argument each row is considered a different feature. In contrast, when
a \Robject{GRangesList} is supplied the highest list-levels
are the different features and the elements of each list
are parts of the same feature. As an example, if \Rcode{features} is 
a \Robject{GRanges} of exons, counts will be returned for each exon. 
If instead \Rcode{features} is a \Robject{GRangesList} of exons by gene, 
the count result would be the length of the \Robject{GRangesList} object 
with counts for each gene.

As sample data for the \Robject{features}, we first use a \Robject{GRanges}
and then split it into a \Robject{GRangesList} to demonstrate how these objects 
allow the user to define features differently. We have a total of 7 reads, 
5 are simple and 2 have gaps in the CIGAR. 

<<data>>=
library(GenomicRanges)

group_id <- c("A", "B", "C", "C", "D", "D", "E", "F", "G", "G", "H", "H")
features <- GRanges(
    seqnames = Rle(c("chr1", "chr2", "chr1", "chr1", "chr2", "chr2",
        "chr1", "chr1", "chr2", "chr2", "chr1", "chr1")),
    strand = strand(rep("+", length(group_id))),
    ranges = IRanges(
        start=c(1000, 2000, 3000, 3600, 7000, 7500, 4000, 4000, 3000, 3350, 5000, 5400),
        width=c(500, 900, 500, 300, 600, 300, 500, 900, 150, 200, 500, 500)),
   DataFrame(group_id)
)

reads <- GappedAlignments(
    names = c("a","b","c","d","e","f","g"),
    rname = Rle(c(rep(c("chr1", "chr2"), 3), "chr1")),
    pos = as.integer(c(1400, 2700, 3400, 7100, 4000, 3100, 5200)),
    cigar = c("500M", "100M", "300M", "500M", "300M", "50M200N50M", "50M150N50M"),
    strand = strand(rep.int("+", 7L)))

@

\newpage

Using a \Robject{GRanges} as the \Rcode{features} we get counts
for each row,
<<GRanges>>=
data.frame(union = assays(countFeatureHits(reads, features))$counts,
           intStrict = assays(countFeatureHits(reads, features,
               mode="IntersectionStrict"))$counts,
           intNotEmpty = assays(countFeatureHits(reads, features,
               mode="IntersectionNotEmpty"))$counts)
@

Working with the same data, we split by group to create a \Robject{GRangesList}. 
The highest list-levels are now the different features and counts are
returned for each group. 
<<lst>>=
lst <- split(features, values(features)[["group_id"]])
length(lst)

<<GRangesList>>=
data.frame(union = assays(countFeatureHits(reads, lst))$counts,
           intStrict = assays(countFeatureHits(reads, lst,
               mode="IntersectionStrict"))$counts,
           intNotEmpty = assays(countFeatureHits(reads, lst,
               mode="IntersectionNotEmpty"))$counts)
@

\section{Refererences}

\url{http://www-huber.embl.de/users/anders/HTSeq/doc/overview.html} 

\url{http://www-huber.embl.de/users/anders/HTSeq/doc/count.html}

\end{document}
