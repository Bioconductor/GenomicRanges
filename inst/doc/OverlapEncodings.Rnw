%\VignetteIndexEntry{Overlap encodings}
%\VignetteDepends{pasillaBamSubset, GenomicRanges, Rsamtools, GenomicFeatures}
%\VignetteKeywords{sequence, sequencing, alignments}
%\VignettePackage{GenomicRanges}
\documentclass[10pt]{article}

\usepackage{times}
\usepackage{hyperref}

\usepackage[margin=0.65in]{geometry}

\newcommand{\Rfunction}[1]{{\texttt{#1}}}
\newcommand{\Robject}[1]{{\texttt{#1}}}
\newcommand{\Rpackage}[1]{{\textsf{#1}}}
\newcommand{\Rmethod}[1]{{\texttt{#1}}}
\newcommand{\Rfunarg}[1]{{\texttt{#1}}}
\newcommand{\Rclass}[1]{{\textit{#1}}}
\newcommand{\Rcode}[1]{{\texttt{#1}}}

\newcommand{\software}[1]{\textsf{#1}}
\newcommand{\R}{\software{R}}
\newcommand{\Bioconductor}{\software{Bioconductor}}

\SweaveOpts{keep.source=TRUE}

\title{Overlap encodings}
\author{Herv\'e Pag\`es}
\date{Last modified: March 2012; Compiled: \today}

\begin{document}

\maketitle

<<options,echo=FALSE>>=
options(width=100)
@
\tableofcontents



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

In the context of an RNA-seq experiment, encoding the overlaps
between 2 \Rclass{GRangesList} objects, one containing the reads (the query),
and one containing the transcripts (the subject), can be used for
detecting hits between reads and transcripts that are ``compatible''
with the splicing of the transcript.

Various tools are provided in the \Rpackage{IRanges} and
\Rpackage{GenomicRanges} packages for working with overlap encodings.
In this vignette, we illustrate the use of these tools on real RNA-seq
data.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Example 1: With single-end reads}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Load the reads and transcripts}

We start by loading some aligned reads into a \Rclass{GappedAlignments} object.
The reads are stored in a BAM file ({\tt untreated1\_chr4.bam}) that is located
in the \Rpackage{pasillaBamSubset} data package. This file contains single-end
reads from an RNA-seq experiment and aligned against the dm3 genome (see
\Rcode{?untreated1\_chr4} in the \Rpackage{pasillaBamSubset} package for more
information about those reads):

<<untreated1_chr4>>=
library(pasillaBamSubset)
untreated1_chr4()
library(GenomicRanges)
gal4 <- readGappedAlignments(untreated1_chr4(), use.names=TRUE)
gal4
table(ngap(gal4))
@

We also need to retrieve the dm3 transcripts and their exons from UCSC,
and extract the exons grouped by transcript in a \Rclass{GRangesList}
object. IMPORTANT: The reference genome of the transcripts must be
{\bf exactly} the same as the reference genome used to align the reads
(note that this is a general rule, not only when working with overlap
encodings):

<<makeTranscriptDbFromUCSC>>=
library(GenomicFeatures)
txdb <- makeTranscriptDbFromUCSC(genome="dm3", tablename="refGene")
exbytx0 <- exonsBy(txdb, by="tx")
@

Before \Rcode{encodeOverlaps()} or related utilities can be used,
exons in transcripts located on the minus strand must be reordered by
decreasing rank:

<<sortExonsByRank>>=
exbytx <- sortExonsByRank(exbytx0, decreasing.rank.on.minus.strand=TRUE)
exbytx0[[20]]
exbytx[[20]]
@


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Find and encode the overlaps}

We are ready to compute the overlaps:

<<findOverlaps>>=
overlaps <- findOverlaps(gal4, exbytx, ignore.strand=TRUE)
@

and to encode them:

<<encodeOverlaps>>=
ovenc <- encodeOverlaps(gal4, exbytx, hits=overlaps, ignore.strand=TRUE)
ovenc
unique_ovenc <- levels(encoding(ovenc))
length(unique_ovenc)
head(unique_ovenc)
tail(sort(table(encoding(ovenc))))
@

Encodings are sort of cryptic but utilities are provided to extract
specific meaning from them. Use of these utilities is covered in the
next three subsections.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Detect overlaps showing ``compatibility'' with the transcript}

We are interested in a particular type of overlap where the read
overlaps the transcript in a ``compatible'' way, that is, in a way
compatible with the splicing of the transcript. We call this an
overlap of type COMPATIBLE\_WITH\_SPLICING.
Use \Rcode{isCompatibleWithSplicing()} on the \Rclass{OverlapEncodings}
object to detect overlaps of type COMPATIBLE\_WITH\_SPLICING.
\Rcode{isCompatibleWithSplicing()} can also be used on the character vector
containing the unique encodings to find those of type
COMPATIBLE\_WITH\_SPLICING i.e. those corresponding to overlaps of this
type.

7 unique encodings are of type COMPATIBLE\_WITH\_SPLICING:

<<compatible_encodings_in_table>>=
table(encoding(ovenc))[isCompatibleWithSplicing(unique_ovenc)]
@

Encodings \Rcode{"1:i:"} (403826 occurences in \Rcode{ovenc}),
\Rcode{"2:jm:af:"} (68914 occurences in \Rcode{ovenc}),
and \Rcode{"3:jmm:agm:aaf:"} (438 occurences in \Rcode{ovenc}),
correspond to the following overlaps:
\begin{itemize}
  \item \Rcode{"1:i:"}
\begin{verbatim}
       read (no gap):            oooooo
          transcript:   ...  oooooooooooo ...
\end{verbatim}
  \item \Rcode{"2:jm:af:"}
\begin{verbatim}
        read (1 gap):              oooo------oo
          transcript:   ...  oooooooooo      ooooooo ...
\end{verbatim}
  \item \Rcode{"3:jmm:agm:aaf:"}
\begin{verbatim}
       read (2 gaps):            ooo-----oo---------ooo
          transcript:   ...  ooooooo     oo         oooooooooo ...
\end{verbatim}
\end{itemize}

Note that the exons represented in the 2nd and 3rd drawings are
consecutive in the transcript. The transcript can have more exons,
which is denoted by the ... on each side of the drawings.

<<>>=
is_compat <- isCompatibleWithSplicing(ovenc)
table(is_compat)  # 476124 overlaps of type COMPATIBLE_WITH_SPLICING
@

For each alignment in \Rcode{gal4}, compute the number of hits (i.e.
overlaps) of type COMPATIBLE\_WITH\_SPLICING:

<<>>=
gal4_compat_nhits <- tabulate(queryHits(overlaps)[is_compat],
                              nbins=length(gal4))
table(gal4_compat_nhits)
@

Number of alignments with at least 1 hit of type COMPATIBLE\_WITH\_SPLICING:

<<>>=
sum(gal4_compat_nhits != 0)
@

\Rcode{gal4\_compat\_nhits != 0} can be used to subset \Rcode{gal4}:

<<>>=
gal4[gal4_compat_nhits != 0]
@

For each transcript in \Rcode{exbytx} (or \Rcode{exbytx0}), compute the number
of hits of type COMPATIBLE\_WITH\_SPLICING:
<<>>=
exbytx_compat_nhits <- tabulate(subjectHits(overlaps)[is_compat],
                                nbins=length(exbytx))
names(exbytx_compat_nhits) <- names(exbytx)
table(exbytx_compat_nhits)
@


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Detect overlaps showing ``almost compatibility'' with the
            transcript}

In many aspects, overlaps of type COMPATIBLE\_WITH\_SPLICING correspond
to an ideal situation but in practise many reads don't fall into that
category.
Here we are interested in a less perfect type of overlap where the
read overlaps the transcript in a way that {\it would} be compatible
if 1 or more exons were removed from the transcript. We call this an
overlap of type COMPATIBLE\_WITH\_SKIPPED\_EXONS.

We can use \Rcode{isCompatibleWithSkippedExons()} on the
\Rclass{OverlapEncodings} object to detect overlaps of type
COMPATIBLE\_WITH\_SKIPPED\_EXONS.
\Rcode{isCompatibleWithSkippedExons()} can also be used on the character
vector containing the unique encodings to find those of type
COMPATIBLE\_WITH\_SKIPPED\_EXONS i.e. those corresponding to overlaps of
this type.

8 unique encodings are of type COMPATIBLE\_WITH\_SKIPPED\_EXONS:
<<>>=
table(encoding(ovenc))[isCompatibleWithSkippedExons(unique_ovenc)]
@

Encoding \Rcode{"2:jm:am:af:"} (696 occurences in \Rcode{ovenc}) corresponds
to the following overlap:

\begin{itemize}
  \item \Rcode{"2:jm:am:af:"}
\begin{verbatim}
        read (1 gap):          ooooo------------ooo
          transcript:   ...  ooooooo    oooo    oooooooo ...
\end{verbatim}
\end{itemize}

<<>>=
is_almost_compat <- isCompatibleWithSkippedExons(ovenc)
table(is_almost_compat)  # 837 overlaps of type COMPATIBLE_WITH_SKIPPED_EXONS
@

For each alignment in \Rcode{gal4}, compute the number of hits (i.e.
overlaps) of type COMPATIBLE\_WITH\_SKIPPED\_EXONS:

<<>>=
gal4_almost_compat_nhits <- tabulate(queryHits(overlaps)[is_almost_compat],
                                     nbins=length(gal4))
table(gal4_almost_compat_nhits)
@

Number of alignments with at least 1 hit of type
COMPATIBLE\_WITH\_SKIPPED\_EXONS:

<<>>=
sum(gal4_almost_compat_nhits != 0) 
@

For each transcript in \Rcode{exbytx} (or \Rcode{exbytx0}), compute
the number of hits of type COMPATIBLE\_WITH\_SKIPPED\_EXONS:

<<>>=
exbytx_almost_compat_nhits <- tabulate(subjectHits(overlaps)[is_almost_compat],
                                       nbins=length(exbytx))
names(exbytx_almost_compat_nhits) <- names(exbytx)
table(exbytx_almost_compat_nhits)
@


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Combining results of \Rcode{isCompatibleWithSplicing()} and
            \Rcode{isCompatibleWithSkippedExons()} to detect novel splice
            junctions}

An alignment in \Rcode{gal4} with hits of type COMPATIBLE\_WITH\_SKIPPED\_EXONS
but no hits of type COMPATIBLE\_WITH\_SPLICING suggests the presence of a
transcript that is not in our annotations.

First we extract the index of those alignments:

<<>>=
aln_shows_nov_splice_jct <- gal4_almost_compat_nhits != 0L &
                            gal4_compat_nhits == 0L
which(aln_shows_nov_splice_jct)
@

We make this an index into \Rcode{overlaps} (Hits object):

<<>>=
is_nov_splice_jct <- queryHits(overlaps) %in%
                         which(aln_shows_nov_splice_jct)
@

We intersect with \Rcode{is\_almost\_compat} to keep only the overlaps
of interest:

<<>>=
is_nov_splice_jct <- is_nov_splice_jct & is_almost_compat
@

For each overlap of interest, we extract the ranks of the skipped
exons (we use a list for this as there might be more than 1 skipped
exon per overlap):

<<>>=
skpexrk <- extractSkippedExonRanks(ovenc)[is_nov_splice_jct]
table(elementLengths(skpexrk))
@

Finally, we split \Rcode{skpexrk} by transcript TxDb internal id:

<<>>=
names(skpexrk) <- queryHits(overlaps)[is_nov_splice_jct]
f <- names(exbytx)[subjectHits(overlaps)[is_nov_splice_jct]]
tx2skpexrk <- split(skpexrk, f)
@

\Rcode{tx2skpexrk} is a named list of named lists of integer vectors.
The first level of names (outer names) are transcript TxDb internal
ids and the second level of names (inner names) are alignment
indices into \Rcode{gal4}:

<<>>=
names(tx2skpexrk)  # transcript TxDb internal ids
@

Transcript \Rcode{"10"} has 7 hits, all of them skip exons 9 and 10:

<<>>=
tx2skpexrk[["10"]]
@

Transcript \Rcode{"58"} has 4 hits. One hit skips exon 2, one hit skips
exons 6 to 10, and two hits skip exon 10:

<<>>=
tx2skpexrk[["58"]]
@

Final remarks:

\begin{itemize}
  \item The exon ranks returned by \Rcode{extractSkippedExonRanks()} are exon
        positions within \Rcode{exbytx}, not \Rcode{exbytx0}. For exons on the
        plus strand, it makes no difference i.e. the ``real'' exon ranks are
        returned. But for exons on the minus strand, we get the ``anti-rank''
        i.e. $N + 1 - rk$ where $N$ is the total nb of exons in the transcript
        and $rk$ the ``real'' exon rank. So for example in the case of
        transcript \Rcode{"58"} (located on the minus strand, see
        \Rcode{exbytx[["58"]]}), exon with ``anti-rank'' 10 is actually at
        rank 2 (the transcript has 11 exons).
  \item Let's be cautious about the interpretation of \Rcode{tx2skpexrk}.
        Because of how we've conducted this analysis, the aligments
        reported in \Rcode{tx2skpexrk} are guaranteed to NOT have any overlaps
        of type COMPATIBLE\_WITH\_SPLICING with other known transcripts.
        All we can say, for example in the case of transcript \Rcode{"10"},
        is that the 4 reported hits show evidence of one or more unknown
        transcripts with a splice junction that corresponds to the gap
        between exons 8 and 11. But without further analysis, we can't
        make any assumption about the exons structure of those unknown
        transcripts. In particular, we cannot assume the existence of an
        unknown transcript made of the same exons as transcript \Rcode{"10"}
        minus exons 9 and 10!
\end{itemize}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Example 2: With paired-end reads}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Load the paired-end reads:

<<readBamGappedAlignmentPairs>>=
untreated3_chr4()
galp4 <- readBamGappedAlignmentPairs(untreated3_chr4(), use.names=TRUE)
galp4
@

Find and encode the overlaps:

<<>>=
overlaps2 <- findOverlaps(galp4, exbytx, ignore.strand=TRUE)
ovenc2 <- encodeOverlaps(galp4, exbytx, overlaps2, ignore.strand=TRUE)
ovenc2
unique_ovenc2 <- levels(encoding(ovenc2))
length(unique_ovenc2)  # 275 unique encodings
head(unique_ovenc2)
enc_table2 <- table(encoding(ovenc2))
tail(sort(enc_table2))
@

Unique encodings ``compatible'' with the splicing of the transcript:

<<>>=
tail(sort(enc_table2[isCompatibleWithSplicing(unique_ovenc2)]))
is_compat2 <- isCompatibleWithSplicing(ovenc2)
table(is_compat2)  # 175225 overlaps are "compatible" with the splicing
@

Nb of ``compatible'' overlaps per alignment pair in \Rcode{galp4}:

<<>>=
galp4_ncompat <- tabulate(queryHits(overlaps2)[is_compat2],
                          nbins=length(galp4))
elementMetadata(galp4)$ncompat <- galp4_ncompat
galp4

table(galp4_ncompat)
@

Number of alignment pairs with at least 1 ``compatible'' overlap with a
transcript:

<<>>=
sum(galp4_ncompat != 0)
@

Nb of compatible overlaps per transcript in \Rcode{exbytx}:

<<>>=
exbytx_ncompat2 <- tabulate(subjectHits(overlaps2)[is_compat2],
                            nbins=length(exbytx))
names(exbytx_ncompat2) <- names(exbytx)
table(exbytx_ncompat2)
@



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{\Rcode{sessionInfo()}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

<<sessionInfo>>=
sessionInfo()
@

\end{document}
