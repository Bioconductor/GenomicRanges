%\VignetteIndexEntry{Overlap encodings}
%\VignetteDepends{pasillaBamSubset, GenomicRanges, Rsamtools, GenomicFeatures}
%\VignetteKeywords{sequence, sequencing, alignments}
%\VignettePackage{GenomicRanges}
\documentclass[10pt]{article}

\usepackage{times}
\usepackage{hyperref}

\usepackage[margin=0.65in]{geometry}

\newcommand{\Rfunction}[1]{{\texttt{#1}}}
\newcommand{\Robject}[1]{{\texttt{#1}}}
\newcommand{\Rpackage}[1]{{\textsf{#1}}}
\newcommand{\Rmethod}[1]{{\texttt{#1}}}
\newcommand{\Rfunarg}[1]{{\texttt{#1}}}
\newcommand{\Rclass}[1]{{\textit{#1}}}
\newcommand{\Rcode}[1]{{\texttt{#1}}}

\newcommand{\software}[1]{\textsf{#1}}
\newcommand{\R}{\software{R}}
\newcommand{\Bioconductor}{\software{Bioconductor}}

\SweaveOpts{keep.source=TRUE}

\title{Overlap encodings}
\author{Herv\'e Pag\`es}
\date{Last modified: March 2012; Compiled: \today}

\begin{document}

\maketitle

<<options,echo=FALSE>>=
options(width=100)
@
\tableofcontents



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

In the context of an RNA-seq experiment, encoding the overlaps between
the aligned reads and the transcripts can be used for detecting those
overlaps that are ``compatible'' with the splicing of the transcript.

Various tools are provided in the \Rpackage{IRanges} and
\Rpackage{GenomicRanges} packages for working with {\it overlap encodings}.
In this vignette, we illustrate the use of these tools on real RNA-seq
data.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Example 1: With single-end reads}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Load the reads and transcripts}

We start by loading some aligned reads into a \Rclass{GappedAlignments} object.
The reads are stored in a BAM file ({\tt untreated1\_chr4.bam}) located
in the \Rpackage{pasillaBamSubset} data package. This file contains single-end
reads from an RNA-seq experiment and aligned against the dm3 genome (see
\Rcode{?untreated1\_chr4} in the \Rpackage{pasillaBamSubset} package for more
information about those reads):

<<untreated1_chr4>>=
library(pasillaBamSubset)
untreated1_chr4()
@

We use the \Rcode{readGappedAlignments} function defined in the
\Rpackage{GenomicRanges} package to read the BAM file into a
\Rclass{GappedAlignments} object.
It's probably a good idea to get rid of the PCR or optical duplicate
(flag bit 0x400 in the SAM format, see the SAM Spec
\footnote{\url{http://samtools.sourceforge.net/}} for the details), as well
as reads not passing quality controls (flag bit 0x200 in the SAM format).
We do this by creating a \Rclass{ScanBamParam} object that we pass to
\Rcode{readGappedAlignments} (see \Rcode{?ScanBamParam} in the
\Rpackage{Rsamtools} package for the details). Note that we also use
\Rcode{use.names=TRUE} in order to load the {\it query template names}
(QNAME field in the SAM format) from the BAM file (\Rcode{readGappedAlignments}
will use them to set the names of the returned object):

<<readGappedAlignments>>=
library(GenomicRanges)
library(Rsamtools)
flag0 <- scanBamFlag(isDuplicate=FALSE, isValidVendorRead=TRUE)
param0 <- ScanBamParam(flag=flag0)
gal14 <- readGappedAlignments(untreated1_chr4(), use.names=TRUE, param=param0)
@

Our reads can have up to 2 gaps (a gap corresponds to an N operation in the
CIGAR):

<<ngap>>=
head(gal14)
table(ngap(gal14))
@

We also need to retrieve the dm3 transcripts and their exons from UCSC,
and extract the exons grouped by transcript in a \Rclass{GRangesList}
object. IMPORTANT: The reference genome of the transcripts must be
{\bf exactly} the same as the reference genome used to align the reads
(note that this is a general rule, not only when working with overlap
encodings):

<<makeTranscriptDbFromUCSC>>=
library(GenomicFeatures)
dm3_refGene_txdb <- makeTranscriptDbFromUCSC(genome="dm3", tablename="refGene")
exbytx <- exonsBy(dm3_refGene_txdb, by="tx")
@

We check that all the exons in any given transcript belong to the same
chromosome and strand. Knowing that our set of transcripts is free of
this kind of trans-splicing events will allow us some significant
simplifications during the downstream analysis \footnote{dealing with
trans-splicing events is not covered in this document}.
A quick and easy way to check this is to take advantage of the fact
that \Rcode{seqnames} and \Rcode{strand} return \Rclass{RleList} objects.
So we can extract the number of Rle runs for each transcript and make
sure it's always 1:

<<no-trans-splicing>>=
table(elementLengths(runLength(seqnames(exbytx))))
table(elementLengths(runLength(strand(exbytx))))
@

Therefore the strand of any given transcript is unambiguously defined
and can be extracted with:

<<exbytx_strand>>=
exbytx_strand <- unlist(runValue(strand(exbytx)), use.names=FALSE)
@


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Find and encode the overlaps}

We are ready to compute the overlaps:

<<ov14>>=
ov14 <- findOverlaps(gal14, exbytx, ignore.strand=TRUE)
@

and to encode them:

<<grl14ab>>=
grl14a <- grglist(gal14, order.as.in.query=TRUE)
grl14b <- flipQuery(grl14a)
@

<<ovenc14ab>>=
ovenc14a <- encodeOverlaps(grl14a, exbytx, hits=ov14)
ovenc14b <- encodeOverlaps(grl14b, exbytx, hits=ov14)
@

<<ovenc14>>=
grl14a_strand <- unlist(runValue(strand(grl14a)), use.names=FALSE)
ovenc14 <- selectEncodingWithCompatibleStrand(ovenc14a, ovenc14b,
                                              grl14a_strand, exbytx_strand,
                                              hits=ov14)
ovenc14
@

<<>>=
unique_ovenc14 <- levels(encoding(ovenc14))
length(unique_ovenc14)
head(unique_ovenc14)
ovenc14_table <- table(encoding(ovenc14))
tail(sort(ovenc14_table))
@

Encodings are sort of cryptic but utilities are provided to extract
specific meaning from them. Use of these utilities is covered in the
next three subsections.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Detect overlaps showing ``compatibility'' with the transcript}

We are interested in a particular type of overlap where the read
overlaps the transcript in a ``compatible'' way, that is, in a way
compatible with the splicing of the transcript. We call this an
overlap of type COMPATIBLE\_WITH\_SPLICING.
Use \Rcode{isCompatibleWithSplicing()} on the \Rclass{OverlapEncodings}
object to detect overlaps of type COMPATIBLE\_WITH\_SPLICING.
\Rcode{isCompatibleWithSplicing()} can also be used on the character vector
containing the unique encodings to find those of type
COMPATIBLE\_WITH\_SPLICING i.e. those corresponding to overlaps of this
type.

7 unique encodings are of type COMPATIBLE\_WITH\_SPLICING:

<<compatible_unique_ovenc14>>=
sort(ovenc14_table[isCompatibleWithSplicing(unique_ovenc14)])
@

Encodings \Rcode{"1:i:"} (403826 occurences in \Rcode{ovenc14}),
\Rcode{"2:jm:af:"} (68914 occurences in \Rcode{ovenc14}),
and \Rcode{"3:jmm:agm:aaf:"} (438 occurences in \Rcode{ovenc14}),
correspond to the following overlaps:

\begin{itemize}
  \item \Rcode{"1:i:"}
\begin{verbatim}
  - read (no gap):           oooooo
  - transcript:     ...  oooooooooooo  ...
\end{verbatim}

  \item \Rcode{"2:jm:af:"}
\begin{verbatim}
  - read (1 gap):              oooo------oo
  - transcript:     ...  oooooooooo      ooooooo  ...
\end{verbatim}

  \item \Rcode{"3:jmm:agm:aaf:"}
\begin{verbatim}
  - read (2 gaps):           ooo-----oo---------oooo
  - transcript:     ...  ooooooo     oo         oooooooooo  ...
\end{verbatim}
\end{itemize}

Note that the exons represented in the 2nd and 3rd drawings are
consecutive in the transcript. The transcript can have more exons,
which is denoted by the ... on each side of the drawings.

Encodings \Rcode{"1:f:"} and \Rcode{"1:j:"} are variations of the situation
described by encoding \Rcode{"1:i:"}. For \Rcode{"1:f:"}, the leftmost
aligned base of the read is aligned with the leftmost base of the exon.
For \Rcode{"1:j:"}, the rightmost aligned base of the read is aligned
with the rightmost base of the exon:

\begin{itemize}
  \item \Rcode{"1:f:"}
\begin{verbatim}
  - read (no gap):       oooooo
  - transcript:     ...  oooooooooooo  ...
\end{verbatim}

  \item \Rcode{"1:j:"}
\begin{verbatim}
  - read (no gap):             oooooo
  - transcript:     ...  oooooooooooo  ...
\end{verbatim}
\end{itemize}

<<ov14_is_compat>>=
ov14_is_compat <- isCompatibleWithSplicing(ovenc14)
table(ov14_is_compat)  # 476124 overlaps of type COMPATIBLE_WITH_SPLICING
@

For each alignment in \Rcode{gal14}, compute the number of hits (i.e.
overlaps) of type COMPATIBLE\_WITH\_SPLICING:

<<gal14_ncompat>>=
gal14_ncompat <- tabulate(queryHits(ov14)[ov14_is_compat],
                          nbins=length(gal14))
elementMetadata(gal14)$ncompat <- gal14_ncompat
head(gal14)
table(gal14_ncompat)
@

Number of alignments with at least 1 hit of type COMPATIBLE\_WITH\_SPLICING:

<<nb_non_zero_gal14_ncompat>>=
sum(gal14_ncompat != 0)
@

For each transcript in \Rcode{exbytx}, compute the number
of hits of type COMPATIBLE\_WITH\_SPLICING:

<<exbytx_ncompat14>>=
exbytx_ncompat14 <- tabulate(subjectHits(ov14)[ov14_is_compat],
                             nbins=length(exbytx))
names(exbytx_ncompat14) <- names(exbytx)
tail(table(exbytx_ncompat14))
@


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Detect overlaps showing ``almost compatibility'' with the
            transcript}

In many aspects, overlaps of type COMPATIBLE\_WITH\_SPLICING correspond
to an ideal situation but in practise many reads don't fall into that
category.
Here we are interested in a less perfect type of overlap where the
read overlaps the transcript in a way that {\it would} be compatible
if 1 or more exons were removed from the transcript. We call this an
overlap of type COMPATIBLE\_WITH\_SKIPPED\_EXONS.

We can use \Rcode{isCompatibleWithSkippedExons()} on the
\Rclass{OverlapEncodings} object to detect overlaps of type
COMPATIBLE\_WITH\_SKIPPED\_EXONS.
\Rcode{isCompatibleWithSkippedExons()} can also be used on the character
vector containing the unique encodings to find those of type
COMPATIBLE\_WITH\_SKIPPED\_EXONS i.e. those corresponding to overlaps of
this type.

7 unique encodings are of type COMPATIBLE\_WITH\_SKIPPED\_EXONS:

<<almost_compatible_unique_ovenc14>>=
sort(ovenc14_table[isCompatibleWithSkippedExons(unique_ovenc14)])
@

Encodings \Rcode{"2:jm:am:af:"} (696 occurences in \Rcode{ovenc14}),
\Rcode{"2:jm:am:am:af:"} (114 occurences in \Rcode{ovenc14}),
and \Rcode{"3:jmm:agm:aam:aaf:"} (18 occurences in \Rcode{ovenc14}),
correspond to the following overlaps:

\begin{itemize}
  \item \Rcode{"2:jm:am:af:"}
\begin{verbatim}
  - read (1 gap):          ooooo------------ooo
  - transcript:     ...  ooooooo    oooo    oooooooo  ...
\end{verbatim}

  \item \Rcode{"2:jm:am:am:af:"}
\begin{verbatim}
  - read (1 gap):          ooooo------------------ooo
  - transcript:     ...  ooooooo   ooooo   oooo   oooooooo  ...
\end{verbatim}

  \item \Rcode{"3:jmm:agm:aam:aaf:"}
\begin{verbatim}
  - read (2 gaps):         ooooo----oooo-----------ooo
  - transcript:     ...  ooooooo    oooo   ooooo   oooooooo  ...
\end{verbatim}
\end{itemize}

<<ov14_is_almostcompat>>=
ov14_is_almostcompat <- isCompatibleWithSkippedExons(ovenc14)
table(ov14_is_almostcompat)  # 837 overlaps of type COMPATIBLE_WITH_SKIPPED_EXONS
@

For each alignment in \Rcode{gal14}, compute the number of hits (i.e.
overlaps) of type COMPATIBLE\_WITH\_SKIPPED\_EXONS:

<<gal14_nalmostcompat>>=
gal14_nalmostcompat <- tabulate(queryHits(ov14)[ov14_is_almostcompat],
                                nbins=length(gal14))
elementMetadata(gal14)$nalmostcompat <- gal14_nalmostcompat
head(gal14)
table(gal14_nalmostcompat)
@

Number of alignments with at least 1 hit of type
COMPATIBLE\_WITH\_SKIPPED\_EXONS:

<<nb_non_zero_gal14_nalmostcompat>>=
sum(gal14_nalmostcompat != 0) 
@

For each transcript in \Rcode{exbytx}, compute
the number of hits of type COMPATIBLE\_WITH\_SKIPPED\_EXONS:

<<exbytx_nalmostcompat14>>=
exbytx_nalmostcompat14 <- tabulate(subjectHits(ov14)[ov14_is_almostcompat],
                                   nbins=length(exbytx))
names(exbytx_nalmostcompat14) <- names(exbytx)
table(exbytx_nalmostcompat14)
@


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Combining results of \Rcode{isCompatibleWithSplicing()} and
            \Rcode{isCompatibleWithSkippedExons()} to detect novel splice
            junctions}

An alignment in \Rcode{gal14} with hits of type COMPATIBLE\_WITH\_SKIPPED\_EXONS
but no hits of type COMPATIBLE\_WITH\_SPLICING suggests the presence of a
transcript that is not in our annotations.

First we extract the index of those alignments:

<<aln_shows_nov_splice_jct>>=
aln_shows_nov_splice_jct <- gal14_nalmostcompat != 0L &
                            gal14_ncompat == 0L
head(which(aln_shows_nov_splice_jct))
@

We make this an index into \Rcode{ov14} (Hits object):

<<is_nov_splice_jct>>=
is_nov_splice_jct <- queryHits(ov14) %in% which(aln_shows_nov_splice_jct)
@

We intersect with \Rcode{is\_almost\_compat} to keep only the overlaps
of interest:

<<narrow_is_nov_splice_jct>>=
is_nov_splice_jct <- is_nov_splice_jct & ov14_is_almostcompat
@

For each overlap of interest, we extract the ranks of the skipped
exons (we use a list for this as there might be more than 1 skipped
exon per overlap):

<<extractSkippedExonRanks>>=
skpexrk <- extractSkippedExonRanks(ovenc14)[is_nov_splice_jct]
table(elementLengths(skpexrk))
@

Finally, we split \Rcode{skpexrk} by transcript TxDb internal id:

<<tx2skpexrk>>=
names(skpexrk) <- queryHits(ov14)[is_nov_splice_jct]
f <- names(exbytx)[subjectHits(ov14)[is_nov_splice_jct]]
tx2skpexrk <- split(skpexrk, f)
@

\Rcode{tx2skpexrk} is a named list of named lists of integer vectors.
The first level of names (outer names) are transcript TxDb internal
ids and the second level of names (inner names) are alignment
indices into \Rcode{gal14}:

<<tx2skpexrk_names>>=
head(names(tx2skpexrk))  # transcript TxDb internal ids
@

Transcript \Rcode{"10"} has 7 hits. Three of them skip exons 4 and 5,
and four of them skip exons 9 and 10:

<<tx10_details>>=
tx2skpexrk[["10"]]
@

Transcript \Rcode{"58"} has 4 hits. Two of them skip exon 2, one of them
skips exons 2 to 6, and one of them skips exon 10:

<<tx58_details>>=
tx2skpexrk[["58"]]
@

A few words about the interpretation of \Rcode{tx2skpexrk}:
Because of how we've conducted this analysis, the aligments
reported in \Rcode{tx2skpexrk} are guaranteed to NOT have any overlaps
of type COMPATIBLE\_WITH\_SPLICING with other known transcripts.
All we can say, for example in the case of transcript \Rcode{"10"},
is that the 4 reported hits that skip exons 9 and 10 show evidence
of one or more unknown transcripts with a splice junction that corresponds
to the gap between exons 8 and 11. But without further analysis, we can't
make any assumption about the exons structure of those unknown transcripts.
In particular, we cannot assume the existence of an unknown transcript
made of the same exons as transcript \Rcode{"10"} minus exons 9 and 10!



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Example 2: With paired-end reads}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Load the reads and transcripts}

We start by loading some aligned paired-end reads into a
\Rclass{GappedAlignmentPairs} object.
The reads are stored in a BAM file ({\tt untreated3\_chr4.bam}) located
in the \Rpackage{pasillaBamSubset} data package. This file contains paired-end
reads from an RNA-seq experiment and aligned against the dm3 genome (see
\Rcode{?untreated3\_chr4} in the \Rpackage{pasillaBamSubset} package for more
information about those reads):

<<untreated3_chr4>>=
untreated3_chr4()
@

We use the \Rcode{readGappedAlignmentPairs} function to read the BAM file
into a \Rclass{GappedAlignmentPairs} object:

<<readGappedAlignmentPairs>>=
galp34 <- readGappedAlignmentPairs(untreated3_chr4(), use.names=TRUE, param=param0)
head(galp34)
@

The \Rcode{show} method for \Rclass{GappedAlignmentPairs} objects displays
two {\tt ranges} columns, one for the {\it first} alignment in the pair (the
left column), and one for the {\it last} alignment in the pair (the right
column). The {\tt strand} column corresponds to the strand of the {\it first}
alignment.

<<first_last>>=
head(first(galp34))
head(last(galp34))
@

According to the SAM format specifications, the aligner is expected to mark
each alignment pair as {\it proper} or not (flag bit 0x2 in the SAM format).
The SAM Spec only says that a pair is {\it proper} if the {\it first} and
{\it last} alignments in the pair are ``properly aligned according to the
aligner''. So the exact criteria used for setting this flag is left to the
aligner.

We use \Rcode{isProperPair} to extract this flag from the
\Rclass{GappedAlignmentPairs} object:

<<isProperPair>>=
table(isProperPair(galp34))
@

Even though we could do {\it overlap encodings} with the full object,
we keep only the {\it proper} pairs for our downstream analysis:

<<keep_only_proper_pairs>>=
galp34 <- galp34[isProperPair(galp34)]
@

For the transcript, we'll reuse the \Rcode{exbytx} object obtained
previously.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Find and encode the overlaps}

Let's compute the overlaps:

<<ov34>>=
ov34 <- findOverlaps(galp34, exbytx, ignore.strand=TRUE)
@

and encode them:

<<grl34ab>>=
grl34a <- grglist(galp34, order.as.in.query=TRUE)
grl34b <- flipQuery(grl34a)
@

<<ovenc34ab>>=
ovenc34a <- encodeOverlaps(grl34a, exbytx, hits=ov34)
ovenc34b <- encodeOverlaps(grl34b, exbytx, hits=ov34)
@

<<ovenc34>>=
grl34a_strand <- unlist(runValue(strand(grl34a)), use.names=FALSE)
ovenc34 <- selectEncodingWithCompatibleStrand(ovenc34a, ovenc34b,
                                              grl34a_strand, exbytx_strand,
                                              hits=ov34)
ovenc34
@

<<>>=
unique_ovenc34 <- levels(encoding(ovenc34))
length(unique_ovenc34)
head(unique_ovenc34)
ovenc34_table <- table(encoding(ovenc34))
tail(sort(ovenc34_table))
@


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Detect overlaps showing ``compatibility'' with the transcript}

Unique encodings ``compatible'' with the splicing of the transcript:

<<compatible_unique_ovenc34>>=
sort(ovenc34_table[isCompatibleWithSplicing(unique_ovenc34)])
@

Encodings \Rcode{"1--1:i--i:"} (89039 occurences in \Rcode{ovenc34}),
\Rcode{"2--1:jm--m:af--i:"} (2825 occurences in \Rcode{ovenc34}),
\Rcode{"1--2:i--jm:a--af:"} (2339 occurences in \Rcode{ovenc34}),
and \Rcode{"1--1:i--m:a--i:"} (342 occurences in \Rcode{ovenc34}),
correspond to the following overlaps:

\begin{itemize}
  \item \Rcode{"1{-}{-}1:i{-}{-}i:"}
\begin{verbatim}
  - paired-end read (no gap on the left end, no gap on the
    right end):            ooo   oooo
  - transcript:   ...  oooooooooooooooo  ...
\end{verbatim}

  \item \Rcode{"2{-}{-}1:jm{-}{-}m:af{-}{-}i:"}
\begin{verbatim}
  - paired-end read (1 gap on the left end, no gap on the
    right end):             oooo-------oo      ooooo
  - transcript:   ...  ooooooooo       ooooooooooooooo  ...
\end{verbatim}

  \item \Rcode{"1{-}{-}2:i{-}{-}jm:a{-}{-}af:"}
\begin{verbatim}
  - paired-end read (no gap on the left end, 1 gap on the
    right end):          ooooo      oo-------oooo
  - transcript:   ...  ooooooooooooooo       ooooooooo  ...
\end{verbatim}

  \item \Rcode{"1{-}{-}1:i{-}{-}m:a{-}{-}i:"}
\begin{verbatim}
  - paired-end read (no gap on the left end, no gap on the
    right end):           ooo           oooo
  - transcript:   ...  oooooooooo      ooooooo  ...
\end{verbatim}
\end{itemize}

<<ov34_is_compat>>=
ov34_is_compat <- isCompatibleWithSplicing(ovenc34)
table(ov34_is_compat)  # 95801 overlaps are "compatible" with the splicing
@

Nb of ``compatible'' overlaps per alignment pair in \Rcode{galp34}:

<<galp34_ncompat>>=
galp34_ncompat <- tabulate(queryHits(ov34)[ov34_is_compat],
                           nbins=length(galp34))
elementMetadata(galp34)$ncompat <- galp34_ncompat
head(galp34)
table(galp34_ncompat)
@

Number of alignment pairs with at least 1 ``compatible'' overlap with a
transcript:

<<nb_non_zero_galp34_ncompat>>=
sum(galp34_ncompat != 0)
@

Nb of ``compatible'' overlaps per transcript in \Rcode{exbytx}:

<<exbytx_ncompat34>>=
exbytx_ncompat34 <- tabulate(subjectHits(ov34)[ov34_is_compat],
                             nbins=length(exbytx))
names(exbytx_ncompat34) <- names(exbytx)
tail(table(exbytx_ncompat34))
@



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{\Rcode{sessionInfo()}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

<<sessionInfo>>=
sessionInfo()
@

\end{document}
