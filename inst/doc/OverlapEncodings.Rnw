%\VignetteIndexEntry{Overlap encodings}
%\VignetteDepends{pasillaBamSubset, GenomicRanges, Rsamtools, GenomicFeatures, BSgenome.Dmelanogaster.UCSC.dm3}
%\VignetteKeywords{sequence, sequencing, alignments}
%\VignettePackage{GenomicRanges}
\documentclass[10pt]{article}

\usepackage{times}
\usepackage{hyperref}

\usepackage[margin=0.65in]{geometry}

\newcommand{\Rfunction}[1]{{\texttt{#1}}}
\newcommand{\Robject}[1]{{\texttt{#1}}}
\newcommand{\Rpackage}[1]{{\textsf{#1}}}
\newcommand{\Rmethod}[1]{{\texttt{#1}}}
\newcommand{\Rfunarg}[1]{{\texttt{#1}}}
\newcommand{\Rclass}[1]{{\textit{#1}}}
\newcommand{\Rcode}[1]{{\texttt{#1}}}

\newcommand{\software}[1]{\textsf{#1}}
\newcommand{\R}{\software{R}}
\newcommand{\Bioconductor}{\software{Bioconductor}}

\SweaveOpts{keep.source=TRUE}

\title{Overlap encodings}
\author{Herv\'e Pag\`es}
\date{Last modified: May 2012; Compiled: \today}

\begin{document}

\maketitle

<<options,echo=FALSE>>=
options(width=100)
.precomputed_results <- system.file("doc", "precomputed_results",
                                    package="GenomicRanges", mustWork=TRUE)
.loadPrecomputed <- function(objname)
{
    filename <- paste0(objname, ".rda")
    path <- file.path(.precomputed_results, filename)
    tempenv <- new.env(parent=emptyenv())
    load(path, envir=tempenv)
    get(objname, envir=tempenv)
}
.checkIdenticalToPrecomputed <- function(obj, objname, ignore.metadata=FALSE)
{
    precomputed_obj <- .loadPrecomputed(objname)
    if (ignore.metadata)
        metadata(obj) <- metadata(precomputed_obj) <- list()
    if (!identical(obj, precomputed_obj))
        stop("'", objname, "' is not identical to precomputed version")
}
@

\tableofcontents



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

In the context of an RNA-seq experiment, encoding the overlaps between
the aligned reads and the transcripts can be used for detecting those
overlaps that are ``compatible'' with the splicing of the transcript.

Various tools are provided in the \Rpackage{IRanges} and
\Rpackage{GenomicRanges} packages for working with {\it overlap encodings}.
In this vignette, we illustrate the use of these tools on the single-end
and paired-end reads of an RNA-seq experiment.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Load the reads and transcripts}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Load single-end reads from a BAM file}

BAM file {\tt untreated1\_chr4.bam} (located in the
\Rpackage{pasillaBamSubset} data package) contains single-end reads from
the ``Pasilla'' experiment and aligned against the dm3 genome (see
\Rcode{?untreated1\_chr4} in the \Rpackage{pasillaBamSubset} package for
more information about those reads):

<<untreated1_chr4>>=
library(pasillaBamSubset)
untreated1_chr4()
@

We use the \Rfunction{readGappedAlignments} function defined in the
\Rpackage{GenomicRanges} package to load the reads into a
\Rclass{GappedAlignments} object.
It's probably a good idea to get rid of the PCR or optical duplicate
(flag bit 0x400 in the SAM format, see the SAM Spec
\footnote{\url{http://samtools.sourceforge.net/}} for the details), as well
as reads not passing quality controls (flag bit 0x200 in the SAM format).
We do this by creating a \Rclass{ScanBamParam} object that we pass to
\Rcode{readGappedAlignments} (see \Rcode{?ScanBamParam} in the
\Rpackage{Rsamtools} package for the details). Note that we also use
\Rcode{use.names=TRUE} in order to load the {\it query template names}
(QNAME field in the SAM format) from the BAM file (\Rcode{readGappedAlignments}
will use them to set the names of the returned object):

<<readGappedAlignments>>=
library(GenomicRanges)
library(Rsamtools)
flag0 <- scanBamFlag(isDuplicate=FALSE, isValidVendorRead=TRUE)
param0 <- ScanBamParam(flag=flag0)
U1gal <- readGappedAlignments(untreated1_chr4(), use.names=TRUE, param=param0)
head(U1gal)
@

Because the aligner used to align those reads can report more than 1 alignment
per {\it original query} (i.e. per sequence stored in the input file,
typically a FASTQ file), we shouldn't expect the names of \Rcode{U1gal} to
be unique:

<<U1gal_names>>=
table(duplicated(names(U1gal)))
@

Our reads can have up to 2 gaps (a gap corresponds to an N operation in the
CIGAR):

<<gaps-in-U1gal>>=
head(unique(cigar(U1gal)))
table(ngap(U1gal))
@

Also, the following table indicates that indels were not allowed/supported 
during the alignment process (no I or D CIGAR operations):

<<no-indels-in-U1gal>>=
colSums(cigarOpTable(cigar(U1gal)))
@


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Load paired-end reads from a BAM file}

BAM file {\tt untreated3\_chr4.bam} (located in the
\Rpackage{pasillaBamSubset} data package) contains paired-end reads from
the ``Pasilla'' experiment and aligned against the dm3 genome (see
\Rcode{?untreated3\_chr4} in the \Rpackage{pasillaBamSubset} package for
more information about those reads).
We use the \Rfunction{readGappedAlignmentPairs} function to load them
into a \Rclass{GappedAlignmentPairs} object:

<<readGappedAlignmentPairs>>=
U3galp <- readGappedAlignmentPairs(untreated3_chr4(), use.names=TRUE, param=param0)
head(U3galp)
@

The \Rcode{show} method for \Rclass{GappedAlignmentPairs} objects displays
two {\tt ranges} columns, one for the {\it first} alignment in the pair (the
left column), and one for the {\it last} alignment in the pair (the right
column). The {\tt strand} column corresponds to the strand of the {\it first}
alignment.

<<first_last>>=
head(first(U3galp))
head(last(U3galp))
@

According to the SAM format specifications, the aligner is expected to mark
each alignment pair as {\it proper} or not (flag bit 0x2 in the SAM format).
The SAM Spec only says that a pair is {\it proper} if the {\it first} and
{\it last} alignments in the pair are ``properly aligned according to the
aligner''. So the exact criteria used for setting this flag is left to the
aligner.

We use \Rcode{isProperPair} to extract this flag from the
\Rclass{GappedAlignmentPairs} object:

<<isProperPair>>=
table(isProperPair(U3galp))
@

Even though we could do {\it overlap encodings} with the full object,
we keep only the {\it proper} pairs for our downstream analysis:

<<keep-only-proper-pairs>>=
U3galp <- U3galp[isProperPair(U3galp)]
@

Because the aligner used to align those reads can report more than 1 alignment
per {\it original query template} (i.e. per pair of sequences stored in the
input files, typically 1 FASTQ file for the {\it first} ends and 1 FASTQ file
for the {\it last} ends), we shouldn't expect the names of \Rcode{U3galp} to
be unique:

<<U3galp_names>>=
table(duplicated(names(U3galp)))
@

Our reads can have up to 1 gap per end:

<<gaps-in-U3galp>>=
head(unique(cigar(first(U3galp))))
head(unique(cigar(last(U3galp))))
table(ngap(first(U3galp)), ngap(last(U3galp)))
@

Like for our single-end reads, the following tables indicate that indels were
not allowed/supported during the alignment process:

<<no-indels-in-U3galp>>=
colSums(cigarOpTable(cigar(first(U3galp))))
colSums(cigarOpTable(cigar(last(U3galp))))
@



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Validate the alignments produced by the aligner}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


In this section we show how to validate the alignments produced by the
aligner by comparing the {\it original query sequences} (aka ``true'' or
``real'' query sequences, or query sequences {\bf before} alignment) with
the {\it reference query sequences} (i.e. the query sequences {\bf after}
alignment).

Note that even though this step is not strictly required for computing
the {\it overlap encodings}, some of the concepts and string-based
computations described in this section are slightly related to some ideas
introduced later in this document.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Validate the single-end alignments}

\subsubsection{Load the {\it original query sequences}}

To load the {\it original query sequences}, we reload the BAM file but now
we explicitely request the SEQ field by using \Rcode{what="seq"} in our call
to \Rfunction{ScanBamParam}. To further validate the alignments produced
by the aligner, we also need to load the NM tag which is a predefined tag
described in the SAM Spec as the ``Edit distance to the reference, including
ambiguous bases but excluding clipping'' (note that tags are optional fields
i.e. not all BAM files have them):

<<U1bamseq>>=
param1 <- ScanBamParam(flag=flag0, what="seq", tag="NM")
U1gal <- readGappedAlignments(untreated1_chr4(), use.names=TRUE, param=param1)
U1bamseq <- elementMetadata(U1gal)$seq
names(U1bamseq) <- names(U1gal)
head(U1bamseq)
@

Because the BAM format imposes that the read sequence is ``reverse
complemented'' when the read is aligned to the minus strand, we ``reverse
complement'' it again to get the {\it original query sequences}:

<<U1oqseq>>=
U1oqseq <- U1bamseq
is_on_minus <- as.logical(strand(U1gal) == "-")
U1oqseq[is_on_minus] <- reverseComplement(U1oqseq[is_on_minus])
head(U1oqseq)
@

Note that sequences with the same {\it query name} correspond to the same
{\it original query} and therefore must be the same. Let's do a quick sanity
check:

<<same-name-implies-same-seq-in-U1oqseq>>=
dup2uniq <- match(names(U1oqseq), names(U1oqseq))
stopifnot(all(U1oqseq[dup2uniq] == U1oqseq))
@

\subsubsection{Compute the {\it reference query sequences}}

The {\it reference query sequences} can easily be computed by extracting
the nucleotides mapped to each read from the reference genome. This of
course requires that we have access to the reference genome used by the
aligner. In Bioconductor, the full genome sequence for the dm3 assembly
is stored in the \Rpackage{BSgenome.Dmelanogaster.UCSC.dm3} data package:

<<Dmelanogaster>>=
library(BSgenome.Dmelanogaster.UCSC.dm3)
Dmelanogaster
@

Let's start by converting our \Rclass{GappedAlignments} object \Rcode{U1gal}
into a \Rclass{GRangesList} object:

<<U1grl>>=
U1grl <- grglist(U1gal, order.as.in.query=TRUE)
@

To extract the portions of the reference genome corresponding to the ranges
in \Rcode{U1grl}, we can use the \Rfunction{extractTranscriptsFromGenome}
function defined in the \Rpackage{GenomicFeatures} package:

<<U1rqseq>>=
library(GenomicFeatures)
U1rqseq <- extractTranscriptsFromGenome(Dmelanogaster, U1grl)
head(U1rqseq)
@

\subsubsection{Compare the {\it original query sequences} with the
               {\it reference query sequences}}

We can use the \Rfunction{neditAt} function defined in the
\Rpackage{Biostrings} package to compute the edit distance between
2 strings. Because the aligned reads have no indels, we should only
see mismatches (typically a small number) during that comparison so
we don't need to call \Rfunction{neditAt} with \Rcode{with.indels=TRUE}.
Because calling \Rfunction{neditAt} in a loop is inefficient, we do this
comparison for the first 500 sequences in \Rcode{U1oqseq} only:

<<U1oqseq-vs-U1rqseq>>=
U1gal_nedit500 <- sapply(1:500, function(i) neditAt(U1oqseq[[i]], U1rqseq[[i]]))
table(U1gal_nedit500)
@

Yes, the first 500 sequences in \Rcode{U1oqseq} are ``close'' to the first
500 sequences in \Rcode{U1rqseq}.

Now let's compare the edit distance reported by \Rfunction{neditAt} with the
edit distance reported by the aligner (NM tag). Because the latter excludes
the N CIGAR operations, it should actually be the same as the former.
We confirm this for the 500 edit distances computed in \Rcode{U1gal\_nedit500}:

<<U1gal_nedit-vs-NM>>=
U1gal_NM <- elementMetadata(U1gal)$NM
stopifnot(all(U1gal_NM[1:500] == U1gal_nedit500))
@

Note that the maximum observed number of mismatches tells us how many
mismatches per read were tolerated by the aligner:

<<up-to-6-mismatches>>=
table(U1gal_NM)
@


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Validate the paired-end alignments}

\subsubsection{Load the {\it original query sequences}}

To load the {\it original query sequences}, we reload the BAM file and
request the SEQ field (and also the NM tag). Since we've removed the improper
pairs from our current \Rcode{U3galp} object, we need to do this again but
now we do it at load time which is equivalent to doing it afterward (i.e.
not only do we have the guarantee to end up with the same elements in
\Rcode{U3galp}, but also to have them in the same order):

<<reload-U3galp>>=
flag2 <- scanBamFlag(isDuplicate=FALSE, isValidVendorRead=TRUE, isProperPair=TRUE)
param2 <- ScanBamParam(flag=flag2, what="seq", tag="NM")
U3galp <- readGappedAlignmentPairs(untreated3_chr4(), use.names=TRUE, param=param2)
@

Let's extract the {\it first} and {\it last} sequences from \Rcode{U3galp}:

<<U3bamseq>>=
U3bamseq_first <- elementMetadata(first(U3galp))$seq
U3bamseq_last <- elementMetadata(last(U3galp))$seq
names(U3bamseq_first) <- names(U3bamseq_last) <- names(U3galp)
head(U3bamseq_first)
head(U3bamseq_last)
@

To obtain the {\it original query sequences} we ``reverse complement''
the sequences that are aligned to the minus strand:

<<U3oqseq>>=
U3oqseq_first <- U3bamseq_first
is_on_minus <- as.logical(strand(first(U3galp)) == "-")
U3oqseq_first[is_on_minus] <- reverseComplement(U3oqseq_first[is_on_minus])

U3oqseq_last <- U3bamseq_last
is_on_minus <- as.logical(strand(last(U3galp)) == "-")
U3oqseq_last[is_on_minus] <- reverseComplement(U3oqseq_last[is_on_minus])
@

Note that sequence pairs with the same {\it query template name} correspond
to the same {\it original query pairs} and therefore should be the same.
Let's do a quick sanity check:

<<same-name-implies-same-seq-pair-in-U3oqseq>>=
dup2uniq <- match(names(U3oqseq_first), names(U3oqseq_first))
stopifnot(all(U3oqseq_first[dup2uniq] == U3oqseq_first))
stopifnot(all(U3oqseq_last[dup2uniq] == U3oqseq_last))
@

\subsubsection{Compute the {\it reference query sequences}}

Because our reads are paired-end, we extract separately the ranges
corresponding to their {\it first} ends (aka {\it first} segments in BAM
jargon) and those corresponding to their {\it last} ends (aka {\it last}
segments in BAM jargon):

<<U3grl_first_and_last>>=
U3grl_first <- grglist(first(U3galp), order.as.in.query=TRUE)
U3grl_last <- grglist(last(U3galp, invert.strand=TRUE), order.as.in.query=TRUE)
@

Then we extract the portions of the reference genome corresponding to the
ranges in \Rclass{GRangesList} objects \Rcode{U3grl\_first} and
\Rcode{U3grl\_last}:

<<U3rqseq>>=
U3rqseq_first <- extractTranscriptsFromGenome(Dmelanogaster, U3grl_first)
U3rqseq_last <- extractTranscriptsFromGenome(Dmelanogaster, U3grl_last)
@

\subsubsection{Compare the {\it original query sequences} with the
               {\it reference query sequences}}

Because the aligned reads have no indels, we should only see mismatches
(typically a small number) during that comparison so we don't need to
call \Rfunction{neditAt} with \Rcode{with.indels=TRUE}.
Let's do this comparison for the first 500 sequences in \Rcode{U3oqseq\_first}
and \Rcode{U3oqseq\_last}:

<<U3oqseq-vs-U3rqseq>>=
U3galp_first_nedit500 <- sapply(1:500, function(i)
    neditAt(U3oqseq_first[[i]], U3rqseq_first[[i]])
)
table(U3galp_first_nedit500)

U3galp_last_nedit500 <- sapply(1:500, function(i)
    neditAt(reverseComplement(U3oqseq_last[[i]]), U3rqseq_last[[i]])
)
table(U3galp_last_nedit500)
@

Yes, the first 500 sequences in \Rcode{U3oqseq\_first} and \Rcode{U3oqseq\_last}
are ``close'' to the first 500 sequences in \Rcode{U3rqseq\_first} and
\Rcode{U3rqseq\_last}, respectively.

Now let's compare the edit distance reported by \Rfunction{neditAt} with the
edit distance reported by the aligner (NM tag). Because the latter excludes
the N CIGAR operations, it should actually be the same as the former.
We confirm this for the 500 edit distances computed in
\Rcode{U3galp\_first\_nedit500} and \Rcode{U3galp\_last\_nedit500}:

<<U3galp_nedit-vs-NM>>=
U3galp_first_NM <- elementMetadata(first(U3galp))$NM
stopifnot(all(U3galp_first_NM[1:500] == U3galp_first_nedit500))

U3galp_last_NM <- elementMetadata(last(U3galp))$NM
stopifnot(all(U3galp_last_NM[1:500] == U3galp_last_nedit500))
@

Note that the following table tells us how many mismatches per read were
tolerated by the aligner:

<<up-to-2-mismatches-per-end>>=
table(U3galp_first_NM, U3galp_last_NM)
@

Up to 2 mismatches per end.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Conclusion}

In addition to validate the alignments produced by the aligner, the
validation described in this section is also an efficient and accurate way
to make sure that the reference genome we've picked up is the same as the
reference genome used by the aligner, at least for the regions covered by
the reads.

In other words, if it's known that the 2 reference genomes are different,
then this validation could still be performed, and, if successful, would
indicate that the 2 genomes are probably substitutable for most analysis
happening downstream of the BAM file.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Find and encode the overlaps between the reads and transcripts}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Load the transcripts from a \Rclass{TranscriptDb} object}

Before we can compute overlaps between reads and transcripts, we need to
retrieve the dm3 transcripts and their exons from UCSC, and extract the
exons grouped by transcript in a \Rclass{GRangesList} object.
IMPORTANT: The reference genome of the transcripts must be {\bf exactly}
the same as the reference genome used to align the reads (note that this
is a general rule, not only when working with overlap encodings).

Let's use the \Rfunction{makeTranscriptDbFromUCSC} defined in the
\Rpackage{GenomicFeatures} to retrieve the dm3 transcripts and their exons
from UCSC:

<<dm3tx>>=
dm3_refGene_txdb <- makeTranscriptDbFromUCSC(genome="dm3", tablename="refGene")
dm3tx <- exonsBy(dm3_refGene_txdb, by="tx")
@
<<CHECK_dm3tx, echo=FALSE, results=hide>>=
.checkIdenticalToPrecomputed(dm3tx, "dm3tx", ignore.metadata=TRUE)
@

We check that all the exons in any given transcript belong to the same
chromosome and strand. Knowing that our set of transcripts is free of
this kind of trans-splicing events will allow us some significant
simplifications during the downstream analysis \footnote{Dealing with
trans-splicing events is not covered in this document}.
A quick and easy way to check this is to take advantage of the fact
that \Rcode{seqnames} and \Rcode{strand} return \Rclass{RleList} objects.
So we can extract the number of Rle runs for each transcript and make
sure it's always 1:

<<check-for-trans-splicing-in-dm3tx>>=
table(elementLengths(runLength(seqnames(dm3tx))))
table(elementLengths(runLength(strand(dm3tx))))
@

Therefore the strand of any given transcript is unambiguously defined
and can be extracted with:

<<dm3tx_strand>>=
dm3tx_strand <- unlist(runValue(strand(dm3tx)), use.names=FALSE)
@


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Single-end overlaps}

We are ready to compute the overlaps with the \Rfunction{findOverlaps}
function. Note that the strand of the queries produced by the RNA-seq
experiment is typically unknown so we use \Rcode{ignore.strand=TRUE}:

<<U1ov>>=
U1ov <- findOverlaps(U1gal, dm3tx, ignore.strand=TRUE)
@

However, the {\it overlap encodings} are strand sensitive so we will
compute them twice, once for the ``original alignments'' (i.e. the alignments
of the {\it original queries}), and once again for the ``flipped alignments''
(i.e. the alignments of the ``flipped queries''). We extract the ranges of
the ``original'' and ``flipped'' alignments in 2 \Rclass{GRangesList} objects
with:

<<U1grlf>>=
U1grlf <- flipQuery(U1grl)  # flipped
@

and encode their overlaps with the transcripts:

<<U1ovencof>>=
U1ovenco <- encodeOverlaps(U1grl, dm3tx, hits=U1ov)
U1ovencf <- encodeOverlaps(U1grlf, dm3tx, hits=U1ov)
@

\Rcode{U1ovenco} and \Rcode{U1ovencf} are 2 \Rclass{OverlapsEncodings}
objects of the same length as \Rclass{Hits} object \Rcode{U1ov}.
For each hit in \Rcode{U1ov}, we have 2 corresponding encodings, one
in \Rcode{U1ovenco} and one in \Rcode{U1ovencf}, but only one of them
encodes a hit between alignment ranges and exon ranges that are on the
same strand.
We use the \Rfunction{selectEncodingWithCompatibleStrand} function
to merge them into a single \Rclass{OverlapsEncodings} of the same
length. For each hit in \Rcode{U1ov}, this selects the encoding
corresponding to alignment ranges and exon ranges with compatible
strand:

<<U1ovenc>>=
U1grl_strand <- unlist(runValue(strand(U1grl)), use.names=FALSE)
U1ovenc <- selectEncodingWithCompatibleStrand(U1ovenco, U1ovencf,
                                              U1grl_strand, dm3tx_strand,
                                              hits=U1ov)
U1ovenc
@

As a convenience, the 2 above calls to \Rfunction{encodeOverlaps} + merging
step can be replaced by a single call to \Rfunction{encodeOverlaps} on
\Rcode{U1grl} (or \Rcode{U1grlf}) with \Rcode{flip.query.if.wrong.strand=TRUE}:

<<U1ovenc_again>>=
U1ovenc_again <- encodeOverlaps(U1grl, dm3tx, hits=U1ov, flip.query.if.wrong.strand=TRUE)
stopifnot(identical(U1ovenc_again, U1ovenc))
@

Unique encodings in \Rcode{U1ovenc}:

<<U1ovenc_table>>=
unique_U1ovenc <- levels(encoding(U1ovenc))
length(unique_U1ovenc)
head(unique_U1ovenc)
U1ovenc_table <- table(encoding(U1ovenc))
tail(sort(U1ovenc_table))
@

Encodings are sort of cryptic but utilities are provided to extract
specific meaning from them. Use of these utilities is covered later in this
document.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Paired-end overlaps}

Let's compute the overlaps:

<<U3ov>>=
U3ov <- findOverlaps(U3galp, dm3tx, ignore.strand=TRUE)
@

and encode them:

<<U3ovenc>>=
U3grl <- grglist(U3galp, order.as.in.query=TRUE)
U3ovenc <- encodeOverlaps(U3grl, dm3tx, hits=U3ov, flip.query.if.wrong.strand=TRUE)
U3ovenc
@

Unique encodings in \Rcode{U3ovenc}:

<<U3ovenc_table>>=
unique_U3ovenc <- levels(encoding(U3ovenc))
length(unique_U3ovenc)
head(unique_U3ovenc)
U3ovenc_table <- table(encoding(U3ovenc))
tail(sort(U3ovenc_table))
@


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{``Compatible'' overlaps}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


We are interested in a particular type of overlap where the read
overlaps the transcript in a ``compatible'' way, that is, in a way
compatible with the splicing of the transcript.
The \Rfunction{isCompatibleWithSplicing} function can be used on an
\Rclass{OverlapEncodings} object to detect this type of overlap.
Note that \Rfunction{isCompatibleWithSplicing} can also be used on a
character vector or factor.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{``Compatible'' single-end overlaps}

\Rcode{U1ovenc} contains 7 unique encodings ``compatible'' with the splicing
of the transcript:

<<compatible_unique_U1ovenc>>=
sort(U1ovenc_table[isCompatibleWithSplicing(unique_U1ovenc)])
@

Encodings \Rcode{"1:i:"} (403826 occurences in \Rcode{U1ovenc}),
\Rcode{"2:jm:af:"} (68914 occurences in \Rcode{U1ovenc}),
and \Rcode{"3:jmm:agm:aaf:"} (438 occurences in \Rcode{U1ovenc}),
correspond to the following overlaps:

\begin{itemize}
  \item \Rcode{"1:i:"}
\begin{verbatim}
  - read (no gap):            oooooooo
  - transcript:     ...   >>>>>>>>>>>>>>   ...
\end{verbatim}

  \item \Rcode{"2:jm:af:"}
\begin{verbatim}
  - read (1 gap):             ooooo---ooo
  - transcript:     ...   >>>>>>>>>   >>>>>>>>>   ...
\end{verbatim}

  \item \Rcode{"3:jmm:agm:aaf:"}
\begin{verbatim}
  - read (2 gaps):              oo---ooooo---o
  - transcript:     ...   >>>>>>>>   >>>>>   >>>>>>>   ...
\end{verbatim}
\end{itemize}

For clarity, only the exons involved in the overlap are represented. The
transcript can of course have more upstream and downstream exons, which
is denoted by the ... on the left side (5' end) and right side (3' end)
of each drawing. Note that the exons represented in the 2nd and 3rd drawings
are consecutive in the transcript.

Encodings \Rcode{"1:f:"} and \Rcode{"1:j:"} are variations of the situation
described by encoding \Rcode{"1:i:"}. For \Rcode{"1:f:"}, the first
aligned base of the read (or ``flipped'' read) is aligned with the first
base of the exon. For \Rcode{"1:j:"}, the last aligned base of the read (or
``flipped'' read) is aligned with the last base of the exon:

\begin{itemize}
  \item \Rcode{"1:f:"}
\begin{verbatim}
  - read (no gap):        oooooooo
  - transcript:     ...   >>>>>>>>>>>>>>   ...
\end{verbatim}

  \item \Rcode{"1:j:"}
\begin{verbatim}
  - read (no gap):              oooooooo
  - transcript:     ...   >>>>>>>>>>>>>>   ...
\end{verbatim}
\end{itemize}

<<U1ov_is_compat>>=
U1ov_is_compat <- isCompatibleWithSplicing(U1ovenc)
table(U1ov_is_compat)  # 476124 "compatible" overlaps
@

Number of ``compatible'' overlaps per alignment in \Rcode{U1gal}:

<<U1gal_ncompat>>=
U1gal_ncompat <- tabulate(queryHits(U1ov)[U1ov_is_compat], nbins=length(U1gal))
elementMetadata(U1gal)$ncompat <- U1gal_ncompat
head(U1gal)
table(U1gal_ncompat)
mean(U1gal_ncompat >= 1)
@

71.45\% of the alignments in \Rcode{U1gal} are ``compatible''
with at least 1 transcript in \Rcode{dm3tx}.

Because \Rcode{U1gal} can (and actually does) contain more than 1 alignment
per {\it original query}, we also count the number of ``compatible'' overlaps
per {\it original query}:

<<U1uqnames_ncompat>>=
## A fast alternative to 'aggregate(FUN=sum)'.
sumByQNAME <- function(x, qnames)
{
    ## We avoid using 'order(qnames)': order() on a character vector is slow
    ## and  "locale" dependent.
    oo <- order(match(qnames, qnames))
    oqnames <- Rle(qnames[oo])
    ans <- diff(c(0L, cumsum(x[oo])[cumsum(runLength(oqnames))]))
    names(ans) <- runValue(oqnames)
    ans
}

U1uqnames_ncompat <- sumByQNAME(U1gal_ncompat, names(U1gal))
table(U1uqnames_ncompat)
mean(U1uqnames_ncompat >= 1)
@

76.54\% of the {\it original queries} are ``compatible'' with at least
1 transcript in \Rcode{dm3tx}.

Number of ``compatible'' overlaps per transcript in \Rcode{dm3tx}:

<<dm3tx_U1ncompat>>=
dm3tx_U1ncompat <- tabulate(subjectHits(U1ov)[U1ov_is_compat], nbins=length(dm3tx))
names(dm3tx_U1ncompat) <- names(dm3tx)
tail(table(dm3tx_U1ncompat))
mean(dm3tx_U1ncompat >= 1)
@

Only 1\% of the transcripts in \Rcode{dm3tx} are ``compatible''
with at least 1 alignment in \Rcode{U1gal}.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{``Compatible'' paired-end overlaps}

\Rcode{U3ovenc} contains 13 unique encodings ``compatible'' with the splicing
of the transcript:

<<compatible_unique_U3ovenc>>=
sort(U3ovenc_table[isCompatibleWithSplicing(unique_U3ovenc)])
@

Encodings \Rcode{"1{-}{-}1:i{-}{-}i:"} (89039 occurences in \Rcode{U3ovenc}),
\Rcode{"2{-}{-}1:jm{-}{-}m:af{-}{-}i:"} (2825 occurences in \Rcode{U3ovenc}),
\Rcode{"1{-}{-}2:i{-}{-}jm:a{-}{-}af:"} (2339 occurences in \Rcode{U3ovenc}),
and \Rcode{"1{-}{-}1:i{-}{-}m:a{-}{-}i:"} (342 occurences in \Rcode{U3ovenc}),
correspond to the following overlaps:

\begin{itemize}
  \item \Rcode{"1{-}{-}1:i{-}{-}i:"}
\begin{verbatim}
  - paired-end read (no gap on the first end, no gap on the
    last end):               oooo   oooo
  - transcript:     ...   >>>>>>>>>>>>>>>>   ...
\end{verbatim}

  \item \Rcode{"2{-}{-}1:jm{-}{-}m:af{-}{-}i:"}
\begin{verbatim}
  - paired-end read (1 gap on the first end, no gap on the
    last end):                 ooo---o    oooo
  - transcript:     ...   >>>>>>>>   >>>>>>>>>>>   ...
\end{verbatim}

  \item \Rcode{"1{-}{-}2:i{-}{-}jm:a{-}{-}af:"}
\begin{verbatim}
  - paired-end read (no gap on the first end, 1 gap on the
    last end):             oooo      oo---oo
  - transcript:     ...  >>>>>>>>>>>>>>   >>>>>>>>>  ...
\end{verbatim}

  \item \Rcode{"1{-}{-}1:i{-}{-}m:a{-}{-}i:"}
\begin{verbatim}
  - paired-end read (no gap on the first end, no gap on the
    last end):               oooo      oooo
  - transcript:     ...   >>>>>>>>>   >>>>>>>   ...
\end{verbatim}
\end{itemize}

Note: switch use of ``first'' and ``last'' above if the read was ``flipped''.

<<U3ov_is_compat>>=
U3ov_is_compat <- isCompatibleWithSplicing(U3ovenc)
table(U3ov_is_compat)  # 95801 "compatible" overlaps
@

Number of ``compatible'' overlaps per alignment pair in \Rcode{U3galp}:

<<U3galp_ncompat>>=
U3galp_ncompat <- tabulate(queryHits(U3ov)[U3ov_is_compat], nbins=length(U3galp))
elementMetadata(U3galp)$ncompat <- U3galp_ncompat
head(U3galp)
table(U3galp_ncompat)
mean(U3galp_ncompat >= 1)
@

66.8\% of the alignment pairs in \Rcode{U3galp} are ``compatible''
with at least 1 transcript in \Rcode{dm3tx}.

Number of ``compatible'' overlaps per {\it original query template}:

<<U3uqnames_ncompat>>=
U3uqnames_ncompat <- sumByQNAME(U3galp_ncompat, names(U3galp))
table(U3uqnames_ncompat)
mean(U3uqnames_ncompat >= 1)
@

70.13\% of the {\it original query templates} are ``compatible'' with at
least 1 transcript in \Rcode{dm3tx}.

Number of ``compatible'' overlaps per transcript in \Rcode{dm3tx}:

<<dm3tx_U3ncompat>>=
dm3tx_U3ncompat <- tabulate(subjectHits(U3ov)[U3ov_is_compat], nbins=length(dm3tx))
names(dm3tx_U3ncompat) <- names(dm3tx)
tail(table(dm3tx_U3ncompat))
mean(dm3tx_U3ncompat >= 1)
@

Only 1\% of the transcripts in \Rcode{dm3tx} are ``compatible''
with at least 1 alignment pair in \Rcode{U3galp}.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Project the reads on the transcriptome}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Project the single-end reads on the transcriptome}

The \Rfunction{extractQueryStartInTranscript} function computes for each
overlap the position of the {\it query start} in the transcript:

<<U1ov_qstart>>=
U1ov_qstart <- extractQueryStartInTranscript(U1grl, dm3tx,
                                             hits=U1ov, ovenc=U1ovenc)
head(subset(U1ov_qstart, U1ov_is_compat))
@

\Rcode{U1ov\_qstart} is a data frame with 1 row per overlap and 3 columns:
\begin{enumerate}
    \item \Rcode{startInTranscript}: the 1-based start position of the
    read with respect to the transcript. Position 1 always corresponds to
    the first base on the 5' end of the transcript sequence.
    \item \Rcode{firstSpannedExonRank}: the rank of the first exon spanned
    by the read, that is, the rank of the exon found at position
    \Rcode{startInTranscript} in the transcript.
    \item \Rcode{startInFirstSpannedExon}: the 1-based start position of the
    read with respect to the first exon spanned by the read.
\end{enumerate}

Having this information allows us for example to compare the read and
transcript nucleotide sequences for each ``compatible'' overlap.
If we use the {\it reference query sequence} instead of the {\it original
query sequence} for this comparison, then it should match {\bf exactly}
the sequence found at the {\it query start} in the transcript.

Let's start by using the \Rfunction{extractTranscriptsFromGenome}
to extract the transcript sequences (aka transcriptome) from the dm3
reference genome:

<<dm3txseq>>=
dm3txseq <- extractTranscriptsFromGenome(Dmelanogaster, dm3tx)
@

For each ``compatible'' overlap, the read sequence in \Rcode{U1rqseq} must
be an {\it exact} substring of the transcript sequence in \Rcode{dm3txseq}:

<<U1ov_rqseq-vs-U1ov_txseq>>=
U1ov_rqseq <- U1rqseq[queryHits(U1ov)]
U1ov_rqseq[flippedQuery(U1ovenc)] <- reverseComplement(U1ov_rqseq[flippedQuery(U1ovenc)])
U1ov_txseq <- dm3txseq[subjectHits(U1ov)]
stopifnot(all(
    U1ov_rqseq[U1ov_is_compat] ==
        narrow(U1ov_txseq[U1ov_is_compat],
               start=U1ov_qstart$startInTranscript[U1ov_is_compat],
               width=width(U1ov_rqseq)[U1ov_is_compat])
))
@

Because of this relationship between the {\it reference query sequence}
and the transcript sequence of a ``compatible'' overlap, and because of
the relationship between the {\it original query sequences} and the
{\it reference query sequences}, then the edit distance reported in the
NM tag is actually the edit distance between the {\it original query} and
the transcript of a ``compatible'' overlap.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Project the paired-end reads on the transcriptome}

For a paired-end read, the {\it query start} is the start of its ``left end''.

<<U3ov_Lqstart>>=
U3ov_Lqstart <- extractQueryStartInTranscript(U3grl, dm3tx,
                                              hits=U3ov, ovenc=U3ovenc)
head(subset(U3ov_Lqstart, U3ov_is_compat))
@

Note that \Rfunction{extractQueryStartInTranscript} can be called with
\Rcode{for.query.right.end=TRUE} if we want this information for the ``right
ends'' of the reads:

<<U3ov_Rqstart>>=
U3ov_Rqstart <- extractQueryStartInTranscript(U3grl, dm3tx,
                                              hits=U3ov, ovenc=U3ovenc,
                                              for.query.right.end=TRUE)
head(subset(U3ov_Rqstart, U3ov_is_compat))
@

Like with single-end reads, having this information allows us for example
to compare the read and transcript nucleotide sequences for each
``compatible'' overlap. If we use the {\it reference query sequence} instead
of the {\it original query sequence} for this comparison, then it should
match {\bf exactly} the sequences of the ``left'' and ``right'' ends of the
read in the transcript.

Let's assign the ``left and right reference query sequences'' to each
overlap:

<<U3ov_Lrqseq_and_Rrqseq>>=
U3ov_Lrqseq <- U3rqseq_first[queryHits(U3ov)]
U3ov_Rrqseq <- U3rqseq_last[queryHits(U3ov)]
@

For the single-end reads, the sequences associated with a ``flipped query''
just needed to be ``reverse complemented''. For paired-end reads, we also
need to swap them between \Rcode{U3ov\_Lrqseq} and \Rcode{U3ov\_Rrqseq}:

<<U3ov_Lrqseq_and_Rrqseq>>=
flip_idx <- which(flippedQuery(U3ovenc))
tmp <- U3ov_Lrqseq[flip_idx]
U3ov_Lrqseq[flip_idx] <- reverseComplement(U3ov_Rrqseq[flip_idx])
U3ov_Rrqseq[flip_idx] <- reverseComplement(tmp)
@

Let's assign the transcript sequence to each overlap:

<<U3ov_txseq>>=
U3ov_txseq <- dm3txseq[subjectHits(U3ov)]
@

For each ``compatible'' overlap, we expect the ``left and right reference
query sequences'' of the read to be {\it exact} substrings of the transcript
sequence. Let's check the ``left reference query sequences'':

<<U3ov_Lrqseq-vs-U3ov_txseq>>=
stopifnot(all(
    U3ov_Lrqseq[U3ov_is_compat] ==
        narrow(U3ov_txseq[U3ov_is_compat],
               start=U3ov_Lqstart$startInTranscript[U3ov_is_compat],
               width=width(U3ov_Lrqseq)[U3ov_is_compat])
))
@

and the ``right reference query sequences'':

<<U3ov_Rrqseq-vs-U3ov_txseq>>=
stopifnot(all(
    U3ov_Rrqseq[U3ov_is_compat] ==
        narrow(U3ov_txseq[U3ov_is_compat],
               start=U3ov_Rqstart$startInTranscript[U3ov_is_compat],
               width=width(U3ov_Rrqseq)[U3ov_is_compat])
))
@



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Align the reads to the transcriptome}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


Aligning the reads to the reference genome is not the most efficient nor
accurate way to count the number of ``compatible'' overlaps per {\it original
query}. Supporting junction reads (i.e. reads that align with at least 1 gap)
introduces a significant computational cost during the alignment process.
Then, as we've seen in the previous sections, each alignment produced by the
aligner needs to be broken into a set of ranges (based on its CIGAR) and
those ranges compared to the ranges of the exons grouped by transcript.

A more straightforward and accurate approach is to align the reads directly
to the transcriptome, and without allowing the typical gap that the aligner
needs to introduce when aligning a junction read to the reference genome.
With this approach, a ``hit'' between a read and a transcript is necessarily
compatible with the splicing of the transcript. In case of a ``hit'', we'll
say that the read and the transcript are ``sequence-based compatible'' (to
differentiate from our previous notion of ``compatible'' overlaps that we
will call ``encoding-based compatible'' from now on, unless the context is
clear).


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Align the single-end reads to the transcriptome}

The single-end reads are in \Rcode{U1oqseq}, the transcriptome is in
\Rcode{dm3txseq}.

Since indels were not allowed/supported during the alignment of the reads to
the reference genome, we don't need to allow/support them either for aligning
the reads to the transcriptome. Also since our goal is to find (and count)
``compatible'' overlaps between reads and transcripts, we don't need to keep
track of the details of the alignments between the reads and the transcripts.
Finally, since BAM file {\tt untreated1\_chr4.bam} is not the full output of
the aligner but the subset obtained by keeping only the alignments located
on chr4, we don't need to align \Rcode{U1oqseq} to the full transcriptome,
but only to the subset of \Rcode{dm3txseq} made of the transcripts located
on chr4.

With those simplifications in mind, we write the following function that we
will use to find the ``hits'' between the reads and the transcriptome:

<<findSequenceHits>>=
### A wrapper to vwhichPDict() that supports ambiguity codes in 'oqseq'
### and 'txseq', and treats them as such.
findSequenceHits <- function(oqseq, txseq, which.txseq=NULL, max.mismatch=0)
{
    .asHits <- function(x, pattern_length)
    {
        query_hits <- unlist(x)
        if (is.null(query_hits))
            query_hits <- integer(0)
        subject_hits <- rep.int(seq_len(length(x)), elementLengths(x))
        new("Hits", queryHits=query_hits, subjectHits=subject_hits,
                    queryLength=pattern_length, subjectLength=length(x))
    }

    if (!is.null(which.txseq)) {
        txseq0_length <- length(txseq)
        txseq <- txseq[which.txseq]
    }

    names(oqseq) <- NULL
    other <- alphabetFrequency(oqseq, baseOnly=TRUE)[ , "other"]
    is_clean <- other == 0L

    ## Find hits for "clean" original queries.
    oqseq0 <- oqseq[is_clean]
    pdict0 <- PDict(oqseq0, max.mismatch=max.mismatch)
    m0 <- vwhichPDict(pdict0, txseq,
                      max.mismatch=max.mismatch, fixed="pattern")
    hits0 <- .asHits(m0, length(oqseq0))
    hits0@queryLength <- length(oqseq)
    hits0@queryHits <- which(is_clean)[hits0@queryHits]

    ## Find hits for non "clean" original queries.
    oqseq1 <- oqseq[!is_clean]
    m1 <- vwhichPDict(oqseq1, txseq,
                      max.mismatch=max.mismatch, fixed=FALSE)
    hits1 <- .asHits(m1, length(oqseq1))
    hits1@queryLength <- length(oqseq)
    hits1@queryHits <- which(!is_clean)[hits1@queryHits]

    ## Combine the hits.
    query_hits <- c(queryHits(hits0), queryHits(hits1))
    subject_hits <- c(subjectHits(hits0), subjectHits(hits1))

    if (!is.null(which.txseq)) {
        subject_hits <- which.txseq[subject_hits]
        hits0@subjectLength <- txseq0_length
    }

    ## Order the hits.
    oo <- IRanges:::orderIntegerPairs(query_hits, subject_hits)
    hits0@queryHits <- query_hits[oo]
    hits0@subjectHits <- subject_hits[oo]
    hits0
}
@

Let's compute the index of the transcripts in \Rcode{dm3txseq} located on chr4
(\Rfunction{findSequenceHits} will restrict the search to those transcripts):

<<which.txseq>>=
dm3chr4tx <- transcripts(dm3_refGene_txdb, vals=list(tx_chrom="chr4"))
dm3chr4txids <- elementMetadata(dm3chr4tx)$tx_id
which.txseq <- match(dm3chr4txids, names(dm3txseq))
@

We know that the aligner tolerated up to 6 mismatches per read.
The following 3 commands find the ``hits'' for the {\it original queries},
then find the ``hits'' for the ``flipped queries'', and finally merge all
the ``hits'' (note that the 3 commands take about 10-12 minutes to complete
on a modern laptop):

<<U1hits, eval=FALSE>>=
U1hits <- findSequenceHits(U1oqseq, dm3txseq,
                           which.txseq=which.txseq, max.mismatch=6)
U1hitsf <- findSequenceHits(reverseComplement(U1oqseq), dm3txseq,
                            which.txseq=which.txseq, max.mismatch=6)
U1hits <- union(U1hits, U1hitsf)
@
<<LOAD_U1hits, echo=FALSE, results=hide>>=
U1hits <- .loadPrecomputed("U1hits")
@

This method finds at least all the ``encoding-based'' compatible overlaps
that we found previsouly plus more:

<<U1hits-vs-U1ov>>=
setdiff(U1ov[U1ov_is_compat], U1hits)
setdiff(U1hits, U1ov[U1ov_is_compat])
@

Number of ``sequence-based compatible'' overlaps per alignment in
\Rcode{U1gal}:

<<U1gal_ncompat2>>=
U1gal_nsbcompat <- tabulate(queryHits(U1hits), nbins=length(U1oqseq))
elementMetadata(U1gal)$nsbcompat <- U1gal_nsbcompat
head(U1gal)
table(U1gal_nsbcompat)
mean(U1gal_nsbcompat >= 1)
@

76.44\% of the alignments in \Rcode{U1gal} are ``sequence-based compatible''
with at least 1 transcript in \Rcode{dm3tx}.

Number of ``sequence-based compatible'' overlaps per {\it original query}:

<<U1uqnames_nsbcompat>>=
U1uqnames_nsbcompat <- sumByQNAME(U1gal_nsbcompat, names(U1gal))
table(U1uqnames_nsbcompat)
mean(U1uqnames_nsbcompat >= 1)
@

77.8\% of the {\it original queries} are ``sequence-based compatible'' with
at least 1 transcript in \Rcode{dm3tx}.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Align the paired-end reads to the transcriptome}

[COMING SOON...]



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{``Almost compatible'' overlaps}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


In many aspects, ``compatible'' overlaps can be seen as perfect.
We are now insterested in a less perfect type of overlap where the
read overlaps the transcript in a way that {\it would} be ``compatible''
if 1 or more exons were removed from the transcript. In that case we say
that the overlap is ``almost compatible'' with the transcript.
The \Rfunction{isCompatibleWithSkippedExons} function can be used on an
\Rclass{OverlapEncodings} object to detect this type of overlap.
Note that \Rfunction{isCompatibleWithSkippedExons} can also be used on a
character vector of factor.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{``Almost compatible'' single-end overlaps}

\Rcode{U1ovenc} contains 7 unique encodings ``almost compatible'' with the
splicing of the transcript:

<<almost_compatible_unique_U1ovenc>>=
sort(U1ovenc_table[isCompatibleWithSkippedExons(unique_U1ovenc)])
@

Encodings \Rcode{"2:jm:am:af:"} (696 occurences in \Rcode{U1ovenc}),
\Rcode{"2:jm:am:am:af:"} (114 occurences in \Rcode{U1ovenc}),
and \Rcode{"3:jmm:agm:aam:aaf:"} (18 occurences in \Rcode{U1ovenc}),
correspond to the following overlaps:

\begin{itemize}
  \item \Rcode{"2:jm:am:af:"}
\begin{verbatim}
  - read (1 gap):           ooooo----------ooo
  - transcript:     ...   >>>>>>>   >>>>   >>>>>>>>   ...
\end{verbatim}

  \item \Rcode{"2:jm:am:am:af:"}
\begin{verbatim}
  - read (1 gap):           ooooo------------------ooo
  - transcript:     ...   >>>>>>>   >>>>   >>>>>   >>>>>>>>   ...
\end{verbatim}

  \item \Rcode{"3:jmm:agm:aam:aaf:"}
\begin{verbatim}
  - read (2 gaps):             oo---oooo-----------oo
  - transcript:     ...   >>>>>>>   >>>>   >>>>>   >>>>>>>>   ...
\end{verbatim}
\end{itemize}

<<U1ov_is_almostcompat>>=
U1ov_is_almostcompat <- isCompatibleWithSkippedExons(U1ovenc)
table(U1ov_is_almostcompat)  # 837 "almost compatible" overlaps
@

Number of ``almost compatible'' overlaps per alignment in \Rcode{U1gal}:

<<U1gal_nalmostcompat>>=
U1gal_nalmostcompat <- tabulate(queryHits(U1ov)[U1ov_is_almostcompat], nbins=length(U1gal))
elementMetadata(U1gal)$nalmostcompat <- U1gal_nalmostcompat
head(U1gal)
table(U1gal_nalmostcompat)
mean(U1gal_nalmostcompat >= 1)
@

Only 0.2\% of the alignments in \Rcode{U1gal} are ``almost compatible''
with at least 1 transcript in \Rcode{dm3tx}.

Number of ``almost compatible'' overlaps per transcript in \Rcode{dm3tx}:

<<dm3tx_U1nalmostcompat>>=
dm3tx_U1nalmostcompat <- tabulate(subjectHits(U1ov)[U1ov_is_almostcompat], nbins=length(dm3tx))
names(dm3tx_U1nalmostcompat) <- names(dm3tx)
table(dm3tx_U1nalmostcompat)
mean(dm3tx_U1nalmostcompat >= 1)
@

Only 0.46\% of the transcripts in \Rcode{dm3tx} are ``almost compatible''
with at least 1 alignment in \Rcode{U1gal}.

Finally note that the ``query start in transcript'' values returned by
\Rfunction{extractQueryStartInTranscript} are also defined for ``almost
compatible'' overlaps:

<<U1ov_qstart>>=
head(subset(U1ov_qstart, U1ov_is_almostcompat))
@


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{``Almost compatible'' paired-end overlaps}

[COMING SOON...]



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Detect novel splice junctions}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{By looking at single-end overlaps}

An alignment in \Rcode{U1gal} with ``almost compatible'' overlaps but
no ``compatible'' overlaps suggests the presence of one or more transcripts
that are not in our annotations.

First we extract the index of those alignments:

<<aln_shows_nov_splice_jct>>=
aln_shows_nov_splice_jct <- U1gal_nalmostcompat != 0L &
                            U1gal_ncompat == 0L
head(which(aln_shows_nov_splice_jct))
@

We make this an index into \Rcode{U1ov} (Hits object):

<<is_nov_splice_jct>>=
is_nov_splice_jct <- queryHits(U1ov) %in% which(aln_shows_nov_splice_jct)
@

We intersect with \Rcode{is\_almost\_compat} to keep only the overlaps
of interest:

<<narrow-is_nov_splice_jct>>=
is_nov_splice_jct <- is_nov_splice_jct & U1ov_is_almostcompat
@

For each overlap of interest, we extract the ranks of the skipped
exons (we use a list for this as there might be more than 1 skipped
exon per overlap):

<<extractSkippedExonRanks>>=
skpexrk <- extractSkippedExonRanks(U1ovenc)[is_nov_splice_jct]
table(elementLengths(skpexrk))
@

Finally, we split \Rcode{skpexrk} by transcript TxDb internal id:

<<tx2skpexrk>>=
names(skpexrk) <- queryHits(U1ov)[is_nov_splice_jct]
f <- names(dm3tx)[subjectHits(U1ov)[is_nov_splice_jct]]
tx2skpexrk <- split(skpexrk, f)
@

\Rcode{tx2skpexrk} is a named list of named lists of integer vectors.
The first level of names (outer names) are transcript TxDb internal
ids and the second level of names (inner names) are alignment
indices into \Rcode{U1gal}:

<<tx2skpexrk_names>>=
head(names(tx2skpexrk))  # transcript TxDb internal ids
@

Transcript \Rcode{"10"} receives 7 hits. All of them skip exons 9 and 10:

<<tx10-details>>=
tx2skpexrk[["10"]]
@

Transcript \Rcode{"58"} receives 4 hits. Two of them skip exon 2, one of them
skips exons 2 to 6, and one of them skips exon 10:

<<tx58-details>>=
tx2skpexrk[["58"]]
@

A few words about the interpretation of \Rcode{tx2skpexrk}:
Because of how we've conducted this analysis, the aligments reported in
\Rcode{tx2skpexrk} are guaranteed to NOT have any ``compatible'' overlaps
with other known transcripts. All we can say, for example in the case of
transcript \Rcode{"10"}, is that the 7 reported hits that skip exons 9 and 10
show evidence of one or more unknown transcripts with a splice junction that
corresponds to the gap between exons 8 and 11. But without further analysis,
we can't make any assumption about the exons structure of those unknown
transcripts. In particular, we cannot assume the existence of an unknown
transcript made of the same exons as transcript \Rcode{"10"} minus exons 9
and 10!


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{By looking at paired-end overlaps}

[COMING SOON...]



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{\Rcode{sessionInfo()}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

<<sessionInfo>>=
sessionInfo()
@

\end{document}
