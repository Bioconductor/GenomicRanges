%\VignetteIndexEntry{Overlap encodings}
%\VignetteDepends{pasillaBamSubset, GenomicRanges, Rsamtools, GenomicFeatures}
%\VignetteKeywords{sequence, sequencing, alignments}
%\VignettePackage{GenomicRanges}
\documentclass[10pt]{article}

\usepackage{times}
\usepackage{hyperref}

\usepackage[margin=0.65in]{geometry}

\newcommand{\Rfunction}[1]{{\texttt{#1}}}
\newcommand{\Robject}[1]{{\texttt{#1}}}
\newcommand{\Rpackage}[1]{{\textsf{#1}}}
\newcommand{\Rmethod}[1]{{\texttt{#1}}}
\newcommand{\Rfunarg}[1]{{\texttt{#1}}}
\newcommand{\Rclass}[1]{{\textit{#1}}}
\newcommand{\Rcode}[1]{{\texttt{#1}}}

\newcommand{\software}[1]{\textsf{#1}}
\newcommand{\R}{\software{R}}
\newcommand{\Bioconductor}{\software{Bioconductor}}

\SweaveOpts{keep.source=TRUE}

\title{Overlap encodings}
\author{Herv\'e Pag\`es}
\date{Last modified: March 2012; Compiled: \today}

\begin{document}

\maketitle

<<options,echo=FALSE>>=
options(width=100)
@
\tableofcontents



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

In the context of an RNA-seq experiment, encoding the overlaps between
the aligned reads and the transcripts can be used for detecting those
overlaps that are ``compatible'' with the splicing of the transcript.

Various tools are provided in the \Rpackage{IRanges} and
\Rpackage{GenomicRanges} packages for working with {\it overlap encodings}.
In this vignette, we illustrate the use of these tools on real RNA-seq
data.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Example 1: With single-end reads}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Load the reads and transcripts}

We start by loading some aligned reads into a \Rclass{GappedAlignments} object.
The reads are stored in a BAM file ({\tt untreated1\_chr4.bam}) located
in the \Rpackage{pasillaBamSubset} data package. This file contains single-end
reads from an RNA-seq experiment and aligned against the dm3 genome (see
\Rcode{?untreated1\_chr4} in the \Rpackage{pasillaBamSubset} package for more
information about those reads):

<<untreated1_chr4>>=
library(pasillaBamSubset)
untreated1_chr4()
library(GenomicRanges)
gal14 <- readGappedAlignments(untreated1_chr4(), use.names=TRUE)
head(gal14)
table(ngap(gal14))
@

We also need to retrieve the dm3 transcripts and their exons from UCSC,
and extract the exons grouped by transcript in a \Rclass{GRangesList}
object. IMPORTANT: The reference genome of the transcripts must be
{\bf exactly} the same as the reference genome used to align the reads
(note that this is a general rule, not only when working with overlap
encodings):

<<makeTranscriptDbFromUCSC>>=
library(GenomicFeatures)
txdb <- makeTranscriptDbFromUCSC(genome="dm3", tablename="refGene")
exbytx0 <- exonsBy(txdb, by="tx")
@

Before \Rcode{encodeOverlaps()} or related utilities can be used,
exons in transcripts located on the minus strand must be reordered by
decreasing rank:

<<sortExonsByRank>>=
exbytx <- sortExonsByRank(exbytx0, decreasing.rank.on.minus.strand=TRUE)
exbytx0[[20]]
exbytx[[20]]
@


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Find and encode the overlaps}

We are ready to compute the overlaps:

<<ov14>>=
ov14 <- findOverlaps(gal14, exbytx, ignore.strand=TRUE)
@

and to encode them:

<<ovenc14>>=
ovenc14 <- encodeOverlaps(gal14, exbytx, hits=ov14, ignore.strand=TRUE)
ovenc14
unique_ovenc14 <- levels(encoding(ovenc14))
length(unique_ovenc14)
head(unique_ovenc14)
ovenc14_table <- table(encoding(ovenc14))
tail(sort(ovenc14_table))
@

Encodings are sort of cryptic but utilities are provided to extract
specific meaning from them. Use of these utilities is covered in the
next three subsections.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Detect overlaps showing ``compatibility'' with the transcript}

We are interested in a particular type of overlap where the read
overlaps the transcript in a ``compatible'' way, that is, in a way
compatible with the splicing of the transcript. We call this an
overlap of type COMPATIBLE\_WITH\_SPLICING.
Use \Rcode{isCompatibleWithSplicing()} on the \Rclass{OverlapEncodings}
object to detect overlaps of type COMPATIBLE\_WITH\_SPLICING.
\Rcode{isCompatibleWithSplicing()} can also be used on the character vector
containing the unique encodings to find those of type
COMPATIBLE\_WITH\_SPLICING i.e. those corresponding to overlaps of this
type.

7 unique encodings are of type COMPATIBLE\_WITH\_SPLICING:

<<compatible_unique_ovenc14>>=
tail(sort(ovenc14_table[isCompatibleWithSplicing(unique_ovenc14)]))
@

Encodings \Rcode{"1:i:"} (403826 occurences in \Rcode{ovenc14}),
\Rcode{"2:jm:af:"} (68914 occurences in \Rcode{ovenc14}),
and \Rcode{"3:jmm:agm:aaf:"} (438 occurences in \Rcode{ovenc14}),
correspond to the following overlaps:

\begin{itemize}
  \item \Rcode{"1:i:"}
\begin{verbatim}
  - read (no gap):           oooooo
  - transcript:     ...  oooooooooooo  ...
\end{verbatim}

  \item \Rcode{"2:jm:af:"}
\begin{verbatim}
  - read (1 gap):              oooo------oo
  - transcript:     ...  oooooooooo      ooooooo  ...
\end{verbatim}

  \item \Rcode{"3:jmm:agm:aaf:"}
\begin{verbatim}
  - read (2 gaps):           ooo-----oo---------oooo
  - transcript:     ...  ooooooo     oo         oooooooooo  ...
\end{verbatim}
\end{itemize}

Note that the exons represented in the 2nd and 3rd drawings are
consecutive in the transcript. The transcript can have more exons,
which is denoted by the ... on each side of the drawings.

Encodings \Rcode{"1:f:"} and \Rcode{"1:j:"} are variations of the situation
described by encoding \Rcode{"1:i:"}. For \Rcode{"1:f:"}, the leftmost
aligned base of the read is aligned with the leftmost base of the exon.
For \Rcode{"1:j:"}, the rightmost aligned base of the read is aligned
with the rightmost base of the exon:

\begin{itemize}
  \item \Rcode{"1:f:"}
\begin{verbatim}
  - read (no gap):       oooooo
  - transcript:     ...  oooooooooooo  ...
\end{verbatim}

  \item \Rcode{"1:j:"}
\begin{verbatim}
  - read (no gap):             oooooo
  - transcript:     ...  oooooooooooo  ...
\end{verbatim}
\end{itemize}

<<ov14_is_compat>>=
ov14_is_compat <- isCompatibleWithSplicing(ovenc14)
table(ov14_is_compat)  # 476124 overlaps of type COMPATIBLE_WITH_SPLICING
@

For each alignment in \Rcode{gal14}, compute the number of hits (i.e.
overlaps) of type COMPATIBLE\_WITH\_SPLICING:

<<gal14_ncompat>>=
gal14_ncompat <- tabulate(queryHits(ov14)[ov14_is_compat],
                          nbins=length(gal14))
elementMetadata(gal14)$ncompat <- gal14_ncompat
head(gal14)
table(gal14_ncompat)
@

Number of alignments with at least 1 hit of type COMPATIBLE\_WITH\_SPLICING:

<<nb_non_zero_gal14_ncompat>>=
sum(gal14_ncompat != 0)
@

For each transcript in \Rcode{exbytx} (or \Rcode{exbytx0}), compute the number
of hits of type COMPATIBLE\_WITH\_SPLICING:

<<exbytx_ncompat14>>=
exbytx_ncompat14 <- tabulate(subjectHits(ov14)[ov14_is_compat],
                             nbins=length(exbytx))
names(exbytx_ncompat14) <- names(exbytx)
tail(table(exbytx_ncompat14))
@


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Detect overlaps showing ``almost compatibility'' with the
            transcript}

In many aspects, overlaps of type COMPATIBLE\_WITH\_SPLICING correspond
to an ideal situation but in practise many reads don't fall into that
category.
Here we are interested in a less perfect type of overlap where the
read overlaps the transcript in a way that {\it would} be compatible
if 1 or more exons were removed from the transcript. We call this an
overlap of type COMPATIBLE\_WITH\_SKIPPED\_EXONS.

We can use \Rcode{isCompatibleWithSkippedExons()} on the
\Rclass{OverlapEncodings} object to detect overlaps of type
COMPATIBLE\_WITH\_SKIPPED\_EXONS.
\Rcode{isCompatibleWithSkippedExons()} can also be used on the character
vector containing the unique encodings to find those of type
COMPATIBLE\_WITH\_SKIPPED\_EXONS i.e. those corresponding to overlaps of
this type.

8 unique encodings are of type COMPATIBLE\_WITH\_SKIPPED\_EXONS:

<<almost_compatible_unique_ovenc14>>=
tail(sort(ovenc14_table[isCompatibleWithSkippedExons(unique_ovenc14)]))
@

Encodings \Rcode{"2:jm:am:af:"} (696 occurences in \Rcode{ovenc14}),
\Rcode{"2:jm:am:am:af:"} (114 occurences in \Rcode{ovenc14}),
and \Rcode{"3:jmm:amm:agm:aaf:"} (11 occurences in \Rcode{ovenc14}),
correspond to the following overlaps:

\begin{itemize}
  \item \Rcode{"2:jm:am:af:"}
\begin{verbatim}
  - read (1 gap):          ooooo------------ooo
  - transcript:     ...  ooooooo    oooo    oooooooo  ...
\end{verbatim}

  \item \Rcode{"2:jm:am:am:af:"}
\begin{verbatim}
  - read (1 gap):          ooooo------------------ooo
  - transcript:     ...  ooooooo   ooooo   oooo   oooooooo  ...
\end{verbatim}

  \item \Rcode{"3:jmm:amm:agm:aaf:"}
\begin{verbatim}
  - read (2 gaps):         ooooo-----------oooo---ooo
  - transcript:     ...  ooooooo   ooooo   oooo   oooooooo  ...
\end{verbatim}
\end{itemize}

<<ov14_is_almostcompat>>=
ov14_is_almostcompat <- isCompatibleWithSkippedExons(ovenc14)
table(ov14_is_almostcompat)  # 837 overlaps of type COMPATIBLE_WITH_SKIPPED_EXONS
@

For each alignment in \Rcode{gal14}, compute the number of hits (i.e.
overlaps) of type COMPATIBLE\_WITH\_SKIPPED\_EXONS:

<<gal14_nalmostcompat>>=
gal14_nalmostcompat <- tabulate(queryHits(ov14)[ov14_is_almostcompat],
                                nbins=length(gal14))
table(gal14_nalmostcompat)
@

Number of alignments with at least 1 hit of type
COMPATIBLE\_WITH\_SKIPPED\_EXONS:

<<nb_non_zero_gal14_nalmostcompat>>=
sum(gal14_nalmostcompat != 0) 
@

For each transcript in \Rcode{exbytx} (or \Rcode{exbytx0}), compute
the number of hits of type COMPATIBLE\_WITH\_SKIPPED\_EXONS:

<<exbytx_nalmostcompat14>>=
exbytx_nalmostcompat14 <- tabulate(subjectHits(ov14)[ov14_is_almostcompat],
                                   nbins=length(exbytx))
names(exbytx_nalmostcompat14) <- names(exbytx)
table(exbytx_nalmostcompat14)
@


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Combining results of \Rcode{isCompatibleWithSplicing()} and
            \Rcode{isCompatibleWithSkippedExons()} to detect novel splice
            junctions}

An alignment in \Rcode{gal14} with hits of type COMPATIBLE\_WITH\_SKIPPED\_EXONS
but no hits of type COMPATIBLE\_WITH\_SPLICING suggests the presence of a
transcript that is not in our annotations.

First we extract the index of those alignments:

<<aln_shows_nov_splice_jct>>=
aln_shows_nov_splice_jct <- gal14_nalmostcompat != 0L &
                            gal14_ncompat == 0L
which(aln_shows_nov_splice_jct)
@

We make this an index into \Rcode{ov14} (Hits object):

<<is_nov_splice_jct>>=
is_nov_splice_jct <- queryHits(ov14) %in% which(aln_shows_nov_splice_jct)
@

We intersect with \Rcode{is\_almost\_compat} to keep only the overlaps
of interest:

<<narrow_is_nov_splice_jct>>=
is_nov_splice_jct <- is_nov_splice_jct & ov14_is_almostcompat
@

For each overlap of interest, we extract the ranks of the skipped
exons (we use a list for this as there might be more than 1 skipped
exon per overlap):

<<skpexrk>>=
skpexrk <- extractSkippedExonRanks(ovenc14)[is_nov_splice_jct]
table(elementLengths(skpexrk))
@

Finally, we split \Rcode{skpexrk} by transcript TxDb internal id:

<<tx2skpexrk>>=
names(skpexrk) <- queryHits(ov14)[is_nov_splice_jct]
f <- names(exbytx)[subjectHits(ov14)[is_nov_splice_jct]]
tx2skpexrk <- split(skpexrk, f)
@

\Rcode{tx2skpexrk} is a named list of named lists of integer vectors.
The first level of names (outer names) are transcript TxDb internal
ids and the second level of names (inner names) are alignment
indices into \Rcode{gal14}:

<<tx2skpexrk_names>>=
names(tx2skpexrk)  # transcript TxDb internal ids
@

Transcript \Rcode{"10"} has 7 hits, all of them skip exons 9 and 10:

<<tx10_details>>=
tx2skpexrk[["10"]]
@

Transcript \Rcode{"58"} has 4 hits. One hit skips exon 2, one hit skips
exons 6 to 10, and two hits skip exon 10:

<<tx58_details>>=
tx2skpexrk[["58"]]
@

Final remarks:

\begin{itemize}
  \item The exon ranks returned by \Rcode{extractSkippedExonRanks()} are exon
        positions within \Rcode{exbytx}, not \Rcode{exbytx0}. For exons on the
        plus strand, it makes no difference i.e. the ``real'' exon ranks are
        returned. But for exons on the minus strand, we get the ``anti-rank''
        i.e. $N + 1 - rk$ where $N$ is the total nb of exons in the transcript
        and $rk$ the ``real'' exon rank. So for example in the case of
        transcript \Rcode{"58"} (located on the minus strand, see
        \Rcode{exbytx[["58"]]}), exon with ``anti-rank'' 10 is actually at
        rank 2 (the transcript has 11 exons).
  \item Let's be cautious about the interpretation of \Rcode{tx2skpexrk}.
        Because of how we've conducted this analysis, the aligments
        reported in \Rcode{tx2skpexrk} are guaranteed to NOT have any overlaps
        of type COMPATIBLE\_WITH\_SPLICING with other known transcripts.
        All we can say, for example in the case of transcript \Rcode{"10"},
        is that the 4 reported hits show evidence of one or more unknown
        transcripts with a splice junction that corresponds to the gap
        between exons 8 and 11. But without further analysis, we can't
        make any assumption about the exons structure of those unknown
        transcripts. In particular, we cannot assume the existence of an
        unknown transcript made of the same exons as transcript \Rcode{"10"}
        minus exons 9 and 10!
\end{itemize}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Example 2: With paired-end reads}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Load the reads and transcripts}

We start by loading some aligned paired-end reads into a
\Rclass{GappedAlignmentPairs} object.
The reads are stored in a BAM file ({\tt untreated3\_chr4.bam}) located
in the \Rpackage{pasillaBamSubset} data package. This file contains paired-end
reads from an RNA-seq experiment and aligned against the dm3 genome (see
\Rcode{?untreated3\_chr4} in the \Rpackage{pasillaBamSubset} package for more
information about those reads):

<<readGappedAlignmentPairs>>=
untreated3_chr4()
galp34 <- readGappedAlignmentPairs(untreated3_chr4(), use.names=TRUE)
head(galp34)
@

For the transcript, we'll reuse the \Rcode{exbytx} object obtained
previously.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Find and encode the overlaps}

Let's compute the overlaps:

<<ov34>>=
ov34 <- findOverlaps(galp34, exbytx, ignore.strand=TRUE)
@

and encode them:

<<ovenc34>>=
ovenc34 <- encodeOverlaps(galp34, exbytx, hits=ov34, ignore.strand=TRUE)
ovenc34
unique_ovenc34 <- levels(encoding(ovenc34))
length(unique_ovenc34)
head(unique_ovenc34)
ovenc34_table <- table(encoding(ovenc34))
tail(sort(ovenc34_table))
@


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Detect overlaps showing ``compatibility'' with the transcript}

Unique encodings ``compatible'' with the splicing of the transcript:

<<compatible_unique_ovenc34>>=
tail(sort(ovenc34_table[isCompatibleWithSplicing(unique_ovenc34)]))
@

Encodings \Rcode{"1--1:i--i:"} (118898 occurences in \Rcode{ovenc34}),
\Rcode{"1--1:i--m:a--i:"} (42107 occurences in \Rcode{ovenc34}),
\Rcode{"1--2:i--jm:a--af:"} (3579 occurences in \Rcode{ovenc34}),
and \Rcode{"1--1:i--m:a--m:a--i:"} (2104 occurences in \Rcode{ovenc34}),
correspond to the following overlaps:

\begin{itemize}
  \item \Rcode{"1{-}{-}1:i{-}{-}i:"}
\begin{verbatim}
  - paired-end read (no gap on the left end, no gap on the
    right end):            ooo   oooo
  - transcript:   ...  oooooooooooooooo  ...
\end{verbatim}

  \item \Rcode{"1{-}{-}1:i{-}{-}m:a{-}{-}i:"}
\begin{verbatim}
  - paired-end read (no gap on the left end, no gap on the
    right end):           ooo           oooo
  - transcript:   ...  oooooooooo      ooooooo  ...
\end{verbatim}

  \item \Rcode{"1{-}{-}2:i{-}{-}jm:a{-}{-}af:"}
\begin{verbatim}
  - paired-end read (no gap on the left end, 1 gap on the
    right end):          ooooo      oo-------oooo
  - transcript:   ...  ooooooooooooooo       ooooooooo  ...
\end{verbatim}

  \item \Rcode{"1{-}{-}1:i{-}{-}m:a{-}{-}m:a{-}{-}i:"}
\begin{verbatim}
  - paired-end read (no gap on the left end, no gap on the
    right end):          ooooo                   oooo
  - transcript:   ...  ooooooooooo   oooooo    ooooooooo  ...
\end{verbatim}
\end{itemize}

<<ov34_is_compat>>=
ov34_is_compat <- isCompatibleWithSplicing(ovenc34)
table(ov34_is_compat)  # 175225 overlaps are "compatible" with the splicing
@

Nb of ``compatible'' overlaps per alignment pair in \Rcode{galp34}:

<<galp34_ncompat>>=
galp34_ncompat <- tabulate(queryHits(ov34)[ov34_is_compat],
                           nbins=length(galp34))
elementMetadata(galp34)$ncompat <- galp34_ncompat
head(galp34)
table(galp34_ncompat)
@

Number of alignment pairs with at least 1 ``compatible'' overlap with a
transcript:

<<nb_non_zero_galp34_ncompat>>=
sum(galp34_ncompat != 0)
@

Nb of ``compatible'' overlaps per transcript in \Rcode{exbytx}:

<<exbytx_ncompat34>>=
exbytx_ncompat34 <- tabulate(subjectHits(ov34)[ov34_is_compat],
                             nbins=length(exbytx))
names(exbytx_ncompat34) <- names(exbytx)
tail(table(exbytx_ncompat34))
@



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{\Rcode{sessionInfo()}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

<<sessionInfo>>=
sessionInfo()
@

\end{document}
