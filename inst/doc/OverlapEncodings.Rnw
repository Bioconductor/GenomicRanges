%\VignetteIndexEntry{Overlap encodings}
%\VignetteDepends{pasillaBamSubset, GenomicRanges, Rsamtools, GenomicFeatures, BSgenome.Dmelanogaster.UCSC.dm3}
%\VignetteKeywords{sequence, sequencing, alignments}
%\VignettePackage{GenomicRanges}
\documentclass[10pt]{article}

\usepackage{times}
\usepackage{hyperref}

\usepackage[margin=0.65in]{geometry}

\newcommand{\Rfunction}[1]{{\texttt{#1}}}
\newcommand{\Robject}[1]{{\texttt{#1}}}
\newcommand{\Rpackage}[1]{{\textsf{#1}}}
\newcommand{\Rmethod}[1]{{\texttt{#1}}}
\newcommand{\Rfunarg}[1]{{\texttt{#1}}}
\newcommand{\Rclass}[1]{{\textit{#1}}}
\newcommand{\Rcode}[1]{{\texttt{#1}}}

\newcommand{\software}[1]{\textsf{#1}}
\newcommand{\R}{\software{R}}
\newcommand{\Bioconductor}{\software{Bioconductor}}

\SweaveOpts{keep.source=TRUE}

\title{Overlap encodings}
\author{Herv\'e Pag\`es}
\date{Last modified: April 2012; Compiled: \today}

\begin{document}

\maketitle

<<options,echo=FALSE>>=
options(width=100)
@
\tableofcontents



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

In the context of an RNA-seq experiment, encoding the overlaps between
the aligned reads and the transcripts can be used for detecting those
overlaps that are ``compatible'' with the splicing of the transcript.

Various tools are provided in the \Rpackage{IRanges} and
\Rpackage{GenomicRanges} packages for working with {\it overlap encodings}.
In this vignette, we illustrate the use of these tools on real RNA-seq
data.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Example 1: With single-end reads}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Load the reads and transcripts}

We start by loading some aligned reads into a \Rclass{GappedAlignments} object.
The reads are stored in a BAM file ({\tt untreated1\_chr4.bam}) located
in the \Rpackage{pasillaBamSubset} data package. This file contains single-end
reads from an RNA-seq experiment and aligned against the dm3 genome (see
\Rcode{?untreated1\_chr4} in the \Rpackage{pasillaBamSubset} package for more
information about those reads):

<<untreated1_chr4>>=
library(pasillaBamSubset)
untreated1_chr4()
@

We use the \Rfunction{readGappedAlignments} function defined in the
\Rpackage{GenomicRanges} package to read the BAM file into a
\Rclass{GappedAlignments} object.
It's probably a good idea to get rid of the PCR or optical duplicate
(flag bit 0x400 in the SAM format, see the SAM Spec
\footnote{\url{http://samtools.sourceforge.net/}} for the details), as well
as reads not passing quality controls (flag bit 0x200 in the SAM format).
We do this by creating a \Rclass{ScanBamParam} object that we pass to
\Rcode{readGappedAlignments} (see \Rcode{?ScanBamParam} in the
\Rpackage{Rsamtools} package for the details). Note that we also use
\Rcode{use.names=TRUE} in order to load the {\it query template names}
(QNAME field in the SAM format) from the BAM file (\Rcode{readGappedAlignments}
will use them to set the names of the returned object):

<<readGappedAlignments>>=
library(GenomicRanges)
library(Rsamtools)
flag0 <- scanBamFlag(isDuplicate=FALSE, isValidVendorRead=TRUE)
param0 <- ScanBamParam(flag=flag0)
U1gal <- readGappedAlignments(untreated1_chr4(), use.names=TRUE, param=param0)
@

Our reads can have up to 2 gaps (a gap corresponds to an N operation in the
CIGAR):

<<ngap>>=
head(U1gal)
table(ngap(U1gal))
@

We also need to retrieve the dm3 transcripts and their exons from UCSC,
and extract the exons grouped by transcript in a \Rclass{GRangesList}
object. IMPORTANT: The reference genome of the transcripts must be
{\bf exactly} the same as the reference genome used to align the reads
(note that this is a general rule, not only when working with overlap
encodings):

<<makeTranscriptDbFromUCSC>>=
library(GenomicFeatures)
dm3_refGene_txdb <- makeTranscriptDbFromUCSC(genome="dm3", tablename="refGene")
dm3tx <- exonsBy(dm3_refGene_txdb, by="tx")
@

We check that all the exons in any given transcript belong to the same
chromosome and strand. Knowing that our set of transcripts is free of
this kind of trans-splicing events will allow us some significant
simplifications during the downstream analysis \footnote{Dealing with
trans-splicing events is not covered in this document}.
A quick and easy way to check this is to take advantage of the fact
that \Rcode{seqnames} and \Rcode{strand} return \Rclass{RleList} objects.
So we can extract the number of Rle runs for each transcript and make
sure it's always 1:

<<check-for-trans-splicing>>=
table(elementLengths(runLength(seqnames(dm3tx))))
table(elementLengths(runLength(strand(dm3tx))))
@

Therefore the strand of any given transcript is unambiguously defined
and can be extracted with:

<<dm3tx_strand>>=
dm3tx_strand <- unlist(runValue(strand(dm3tx)), use.names=FALSE)
@


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Find and encode the overlaps}

We are ready to compute the overlaps with the \Rfunction{findOverlaps}
function. Note that the strand of the queries produced by the RNA-seq
experiment is typically unknown so we use \Rcode{ignore.strand=TRUE}:

<<U1ov>>=
U1ov <- findOverlaps(U1gal, dm3tx, ignore.strand=TRUE)
@

However, the {\it overlap encodings} are strand sensitive so we will
compute them twice, once for the original alignments (i.e. the alignments
of the original queries), and once again for the ``flipped alignments''
(i.e. the alignments of the flipped queries). We extract the ranges of
the original and flipped alignments in 2 \Rclass{GRangesList} objects
with:

<<U1grl>>=
U1grl <- grglist(U1gal, order.as.in.query=TRUE)  # not flipped
U1grlf <- flipQuery(U1grl)  # flipped
@

and encode their overlaps with the transcripts:

<<U1ovencof>>=
U1ovenco <- encodeOverlaps(U1grl, dm3tx, hits=U1ov)
U1ovencf <- encodeOverlaps(U1grlf, dm3tx, hits=U1ov)
@

\Rcode{U1ovenco} and \Rcode{U1ovencf} are 2 \Rclass{OverlapsEncodings}
objects of the same length as \Rclass{Hits} object \Rcode{U1ov}.
For each hit in \Rcode{U1ov}, we have 2 corresponding encodings, one
in \Rcode{U1ovenco} and one in \Rcode{U1ovencf}, but only one of them
encodes a hit between alignment ranges and exon ranges that are on the
same strand.
We use the \Rfunction{selectEncodingWithCompatibleStrand} function
to merge them into a single \Rclass{OverlapsEncodings} of the same
length. For each hit in \Rcode{U1ov}, this selects the encoding
corresponding to alignment ranges and exon ranges with compatible
strand:

<<U1ovenc>>=
U1grl_strand <- unlist(runValue(strand(U1grl)), use.names=FALSE)
U1ovenc <- selectEncodingWithCompatibleStrand(U1ovenco, U1ovencf,
                                              U1grl_strand, dm3tx_strand,
                                              hits=U1ov)
U1ovenc
@

As a convenience, the 2 above calls to \Rfunction{encodeOverlaps} + merging
step can be replaced by a single call to \Rfunction{encodeOverlaps} on
\Rcode{U1grl} (or \Rcode{U1grlf}) with \Rcode{flip.query.if.wrong.strand=TRUE}:

<<U1ovenc_again>>=
U1ovenc_again <- encodeOverlaps(U1grl, dm3tx, hits=U1ov, flip.query.if.wrong.strand=TRUE)
stopifnot(identical(U1ovenc_again, U1ovenc))
@

Unique encodings in \Rcode{U1ovenc}:

<<U1ovenc_table>>=
unique_U1ovenc <- levels(encoding(U1ovenc))
length(unique_U1ovenc)
head(unique_U1ovenc)
U1ovenc_table <- table(encoding(U1ovenc))
tail(sort(U1ovenc_table))
@

Encodings are sort of cryptic but utilities are provided to extract
specific meaning from them. Use of these utilities is covered in the
next four subsections.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{``Compatible'' overlaps}

We are interested in a particular type of overlap where the read
overlaps the transcript in a ``compatible'' way, that is, in a way
compatible with the splicing of the transcript.
The \Rfunction{isCompatibleWithSplicing} function can be used on an
\Rclass{OverlapEncodings} object to detect this type of overlap.
Note that \Rfunction{isCompatibleWithSplicing} can also be used on a
character vector or factor.

\Rcode{U1ovenc} contains 7 unique encodings ``compatible'' with the splicing
of the transcript:

<<compatible_unique_U1ovenc>>=
sort(U1ovenc_table[isCompatibleWithSplicing(unique_U1ovenc)])
@

Encodings \Rcode{"1:i:"} (403826 occurences in \Rcode{U1ovenc}),
\Rcode{"2:jm:af:"} (68914 occurences in \Rcode{U1ovenc}),
and \Rcode{"3:jmm:agm:aaf:"} (438 occurences in \Rcode{U1ovenc}),
correspond to the following overlaps:

\begin{itemize}
  \item \Rcode{"1:i:"}
\begin{verbatim}
  - read (no gap):            oooooooo
  - transcript:     ...   >>>>>>>>>>>>>>   ...
\end{verbatim}

  \item \Rcode{"2:jm:af:"}
\begin{verbatim}
  - read (1 gap):             ooooo---ooo
  - transcript:     ...   >>>>>>>>>   >>>>>>>>>   ...
\end{verbatim}

  \item \Rcode{"3:jmm:agm:aaf:"}
\begin{verbatim}
  - read (2 gaps):              oo---ooooo---o
  - transcript:     ...   >>>>>>>>   >>>>>   >>>>>>>   ...
\end{verbatim}
\end{itemize}

For clarity, only the exons involved in the overlap are represented. The
transcript can of course have more upstream and downstream exons, which
is denoted by the ... on the left side (5' end) and right side (3' end)
of each drawing. Note that the exons represented in the 2nd and 3rd drawings
are consecutive in the transcript.

Encodings \Rcode{"1:f:"} and \Rcode{"1:j:"} are variations of the situation
described by encoding \Rcode{"1:i:"}. For \Rcode{"1:f:"}, the first
aligned base of the read (or flipped read) is aligned with the first base
of the exon. For \Rcode{"1:j:"}, the last aligned base of the read (or
flipped read) is aligned with the last base of the exon:

\begin{itemize}
  \item \Rcode{"1:f:"}
\begin{verbatim}
  - read (no gap):        oooooooo
  - transcript:     ...   >>>>>>>>>>>>>>   ...
\end{verbatim}

  \item \Rcode{"1:j:"}
\begin{verbatim}
  - read (no gap):              oooooooo
  - transcript:     ...   >>>>>>>>>>>>>>   ...
\end{verbatim}
\end{itemize}

<<U1ov_is_compat>>=
U1ov_is_compat <- isCompatibleWithSplicing(U1ovenc)
table(U1ov_is_compat)  # 476124 "compatible" overlaps
@

Number of ``compatible'' overlaps per alignment in \Rcode{U1gal}:

<<U1gal_ncompat>>=
U1gal_ncompat <- tabulate(queryHits(U1ov)[U1ov_is_compat], nbins=length(U1gal))
elementMetadata(U1gal)$ncompat <- U1gal_ncompat
head(U1gal)
table(U1gal_ncompat)
mean(U1gal_ncompat >= 1)
@

71.45\% of the alignments in \Rcode{U1gal} are ``compatible''
with at least 1 transcript in \Rcode{dm3tx}.

Number of ``compatible'' overlaps per transcript in \Rcode{dm3tx}:

<<dm3tx_U1ncompat>>=
dm3tx_U1ncompat <- tabulate(subjectHits(U1ov)[U1ov_is_compat], nbins=length(dm3tx))
names(dm3tx_U1ncompat) <- names(dm3tx)
tail(table(dm3tx_U1ncompat))
mean(dm3tx_U1ncompat >= 1)
@

Only 1\% of the transcripts in \Rcode{dm3tx} are ``compatible''
with at least 1 alignment in \Rcode{U1gal}.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Projecting the reads on the transcripts}

The \Rfunction{extractQueryStartInTranscript} function computes for each
overlap the position of the {\it query start} in the transcript:

<<U1ov_qstart>>=
U1ov_qstart <- extractQueryStartInTranscript(U1grl, dm3tx,
                                             hits=U1ov, ovenc=U1ovenc)
head(subset(U1ov_qstart, U1ov_is_compat))
@

\Rcode{U1ov\_qstart} is a data frame with 1 row per overlap and 3 columns:
\begin{enumerate}
    \item \Rcode{startInTranscript}: the 1-based start position of the
    read with respect to the transcript. Position 1 always corresponds to
    the first base on the 5' end of the transcript sequence.
    \item \Rcode{firstSpannedExonRank}: the rank of the first exon spanned
    by the read, that is, the rank of the exon found at position
    \Rcode{startInTranscript} in the transcript.
    \item \Rcode{startInFirstSpannedExon}: the 1-based start position of the
    read with respect to the first exon spanned by the read.
\end{enumerate}

Having this information allows us for example to compare the read and
transcript nucleotide sequences for each ``compatible'' overlap.
Let's start by using the \Rfunction{extractTranscriptsFromGenome}
function from the \Rpackage{GenomicFeatures} package to extract the
transcript sequences from the \Rpackage{BSgenome.Dmelanogaster.UCSC.dm3}
data package:

<<txseq>>=
library(BSgenome.Dmelanogaster.UCSC.dm3)
txseq <- extractTranscriptsFromGenome(Dmelanogaster, dm3tx)
@

As a sanity check, instead of the ``real'' read sequences, we'll use the
sequences extracted from the reference genome based on the ranges in
\Rcode{U1grl}. We can reuse \Rfunction{extractTranscriptsFromGenome} for
this:

<<U1qseq>>=
U1qseq <- extractTranscriptsFromGenome(Dmelanogaster, U1grl)
@

Now we compare the read and transcript sequences for each ``compatible''
overlap. Because the read sequences (in \Rcode{U1qseq}) and the transcript
sequences (in \Rcode{txseq}) were both extracted from the reference genome,
we expect the formers to be {\it exact} substrings of the latters:

<<U1ov_qseq_vs_U1ov_txseq>>=
U1ov_qseq <- U1qseq[queryHits(U1ov)]
U1ov_qseq[flippedQuery(U1ovenc)] <- reverseComplement(U1ov_qseq[flippedQuery(U1ovenc)])
U1ov_txseq <- txseq[subjectHits(U1ov)]
stopifnot(all(
    U1ov_qseq[U1ov_is_compat] == narrow(U1ov_txseq[U1ov_is_compat],
                                        start=U1ov_qstart$startInTranscript[U1ov_is_compat],
                                        width=width(U1ov_qseq)[U1ov_is_compat])
))
@

Doing the above with the ``real'' read sequences (i.e. the sequences stored
in the SEQ field of BAM file {\tt untreated1\_chr4.bam}) would imply dealing
with possible mismatches and indels introduced by the aligner.

To load the ``real'' read sequences, we reload the BAM file but now we
explicitely request the SEQ field by using \Rcode{what="seq"} in our call to
\Rfunction{ScanBamParam}. We also load the NM tag, which is a predefined tag
described in the SAM Spec as the ``Edit distance to the reference, including
ambiguous bases but excluding clipping'' (note that tags are optional fields
i.e. not all BAM files have them):

<<U1bamseq>>=
param1 <- ScanBamParam(flag=flag0, what="seq", tag="NM")
U1gal <- readGappedAlignments(untreated1_chr4(), use.names=TRUE, param=param1)
U1bamseq <- elementMetadata(U1gal)$seq
names(U1bamseq) <- names(U1gal)
head(U1bamseq)
@

Because the BAM format imposes that the read sequence is ``reverse
complemented'' when the read is aligned to the minus strand, we need
to ``reverse complement'' it again to get the {\it original} sequence
(i.e. the sequence stored in the file used as input to the aligner,
typically a FASTQ file):

<<U1seq>>=
U1seq <- U1bamseq
is_on_minus <- as.logical(strand(U1gal) == "-")
U1seq[is_on_minus] <- reverseComplement(U1seq[is_on_minus])
head(U1seq)
@

The following table indicates that indels were not allowed/supported 
during the alignment process (no I or D CIGAR operations):

<<no_indels_in_U1gal>>=
colSums(cigarOpTable(cigar(U1gal)))
@

So we should only see mismatches (typically a small number) between the
sequences in \Rcode{U1seq} and those in \Rcode{U1qseq}, but no indels,
thus we don't need to call \Rfunction{neditAt} with \Rcode{with.indels=TRUE}
when comparing the read and transcript sequences. We do this comparison for
the first 500 sequences in \Rcode{U1gal}:

<<U1seq_vs_U1qseq>>=
U1gal_nedit500 <- sapply(1:500, function(i) neditAt(U1seq[[i]], U1qseq[[i]]))
table(U1gal_nedit500)
@

Because the edit distance reported by the aligner in the NM tag excludes the
N CIGAR operations, it should actually be the same as the value returned by
\Rfunction{neditAt}. We confirm this for the 500 edit distances in
\Rcode{U1gal\_nedit500}:

<<U1gal_nedit>>=
U1gal_nedit <- elementMetadata(U1gal)$NM
stopifnot(all(U1gal_nedit[1:500] == U1gal_nedit500))
@

Finally, the maximum observed number of mismatches tells us how many
mismatches per read were tolerated by the aligner:

<<up_to_6_mismatches>>=
table(U1gal_nedit)
@


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{``Almost compatible'' overlaps}

In many aspects, ``compatible'' overlaps correspond to an ideal situation
but in practise many overlaps don't fall into that category.
Here we are interested in a less perfect type of overlap where the
read overlaps the transcript in a way that {\it would} be ``compatible''
if 1 or more exons were removed from the transcript. In that case we say
that the overlap is ``almost compatible'' with the transcript.
The \Rfunction{isCompatibleWithSkippedExons} function can be used on an
\Rclass{OverlapEncodings} object to detect this type of overlap.
Note that \Rfunction{isCompatibleWithSkippedExons} can also be used on a
character vector of factor.

\Rcode{U1ovenc} contains 7 unique encodings ``almost compatible'' with the
splicing of the transcript:

<<almost_compatible_unique_U1ovenc>>=
sort(U1ovenc_table[isCompatibleWithSkippedExons(unique_U1ovenc)])
@

Encodings \Rcode{"2:jm:am:af:"} (696 occurences in \Rcode{U1ovenc}),
\Rcode{"2:jm:am:am:af:"} (114 occurences in \Rcode{U1ovenc}),
and \Rcode{"3:jmm:agm:aam:aaf:"} (18 occurences in \Rcode{U1ovenc}),
correspond to the following overlaps:

\begin{itemize}
  \item \Rcode{"2:jm:am:af:"}
\begin{verbatim}
  - read (1 gap):           ooooo----------ooo
  - transcript:     ...   >>>>>>>   >>>>   >>>>>>>>   ...
\end{verbatim}

  \item \Rcode{"2:jm:am:am:af:"}
\begin{verbatim}
  - read (1 gap):           ooooo------------------ooo
  - transcript:     ...   >>>>>>>   >>>>   >>>>>   >>>>>>>>   ...
\end{verbatim}

  \item \Rcode{"3:jmm:agm:aam:aaf:"}
\begin{verbatim}
  - read (2 gaps):             oo---oooo-----------oo
  - transcript:     ...   >>>>>>>   >>>>   >>>>>   >>>>>>>>   ...
\end{verbatim}
\end{itemize}

<<U1ov_is_almostcompat>>=
U1ov_is_almostcompat <- isCompatibleWithSkippedExons(U1ovenc)
table(U1ov_is_almostcompat)  # 837 "almost compatible" overlaps
@

Number of ``almost compatible'' overlaps per alignment in \Rcode{U1gal}:

<<U1gal_nalmostcompat>>=
U1gal_nalmostcompat <- tabulate(queryHits(U1ov)[U1ov_is_almostcompat], nbins=length(U1gal))
elementMetadata(U1gal)$nalmostcompat <- U1gal_nalmostcompat
head(U1gal)
table(U1gal_nalmostcompat)
mean(U1gal_nalmostcompat >= 1)
@

Only 0.2\% of the alignments in \Rcode{U1gal} are ``almost compatible''
with at least 1 transcript in \Rcode{dm3tx}.

Number of ``almost compatible'' overlaps per transcript in \Rcode{dm3tx}:

<<dm3tx_U1nalmostcompat>>=
dm3tx_U1nalmostcompat <- tabulate(subjectHits(U1ov)[U1ov_is_almostcompat], nbins=length(dm3tx))
names(dm3tx_U1nalmostcompat) <- names(dm3tx)
table(dm3tx_U1nalmostcompat)
mean(dm3tx_U1nalmostcompat >= 1)
@

Only 0.46\% of the transcripts in \Rcode{dm3tx} are ``almost compatible''
with at least 1 alignment in \Rcode{U1gal}.

Finally note that the ``query start in transcript'' values returned by
\Rfunction{extractQueryStartInTranscript} are also defined for ``almost
compatible'' overlaps:

<<U1ov_qstart>>=
head(subset(U1ov_qstart, U1ov_is_almostcompat))
@


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Detect novel splice junctions}

An alignment in \Rcode{U1gal} with ``almost compatible'' hits but
no ``compatible'' hits suggests the presence of one or more transcripts that
are not in our annotations.

First we extract the index of those alignments:

<<aln_shows_nov_splice_jct>>=
aln_shows_nov_splice_jct <- U1gal_nalmostcompat != 0L &
                            U1gal_ncompat == 0L
head(which(aln_shows_nov_splice_jct))
@

We make this an index into \Rcode{U1ov} (Hits object):

<<is_nov_splice_jct>>=
is_nov_splice_jct <- queryHits(U1ov) %in% which(aln_shows_nov_splice_jct)
@

We intersect with \Rcode{is\_almost\_compat} to keep only the overlaps
of interest:

<<narrow_is_nov_splice_jct>>=
is_nov_splice_jct <- is_nov_splice_jct & U1ov_is_almostcompat
@

For each overlap of interest, we extract the ranks of the skipped
exons (we use a list for this as there might be more than 1 skipped
exon per overlap):

<<extractSkippedExonRanks>>=
skpexrk <- extractSkippedExonRanks(U1ovenc)[is_nov_splice_jct]
table(elementLengths(skpexrk))
@

Finally, we split \Rcode{skpexrk} by transcript TxDb internal id:

<<tx2skpexrk>>=
names(skpexrk) <- queryHits(U1ov)[is_nov_splice_jct]
f <- names(dm3tx)[subjectHits(U1ov)[is_nov_splice_jct]]
tx2skpexrk <- split(skpexrk, f)
@

\Rcode{tx2skpexrk} is a named list of named lists of integer vectors.
The first level of names (outer names) are transcript TxDb internal
ids and the second level of names (inner names) are alignment
indices into \Rcode{U1gal}:

<<tx2skpexrk_names>>=
head(names(tx2skpexrk))  # transcript TxDb internal ids
@

Transcript \Rcode{"10"} has 7 hits. All of them skip exons 9 and 10:

<<tx10_details>>=
tx2skpexrk[["10"]]
@

Transcript \Rcode{"58"} has 4 hits. Two of them skip exon 2, one of them
skips exons 2 to 6, and one of them skips exon 10:

<<tx58_details>>=
tx2skpexrk[["58"]]
@

A few words about the interpretation of \Rcode{tx2skpexrk}:
Because of how we've conducted this analysis, the aligments reported in
\Rcode{tx2skpexrk} are guaranteed to NOT have any ``compatible'' overlaps
with other known transcripts. All we can say, for example in the case of
transcript \Rcode{"10"}, is that the 7 reported hits that skip exons 9 and 10
show evidence of one or more unknown transcripts with a splice junction that
corresponds to the gap between exons 8 and 11. But without further analysis,
we can't make any assumption about the exons structure of those unknown
transcripts. In particular, we cannot assume the existence of an unknown
transcript made of the same exons as transcript \Rcode{"10"} minus exons 9
and 10!


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Example 2: With paired-end reads}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Load the reads and transcripts}

We start by loading some aligned paired-end reads into a
\Rclass{GappedAlignmentPairs} object.
The reads are stored in a BAM file ({\tt untreated3\_chr4.bam}) located
in the \Rpackage{pasillaBamSubset} data package. This file contains paired-end
reads from an RNA-seq experiment and aligned against the dm3 genome (see
\Rcode{?untreated3\_chr4} in the \Rpackage{pasillaBamSubset} package for more
information about those reads):

<<untreated3_chr4>>=
untreated3_chr4()
@

We use the \Rfunction{readGappedAlignmentPairs} function to read the BAM file
into a \Rclass{GappedAlignmentPairs} object:

<<readGappedAlignmentPairs>>=
U3galp <- readGappedAlignmentPairs(untreated3_chr4(), use.names=TRUE, param=param0)
head(U3galp)
@

The \Rcode{show} method for \Rclass{GappedAlignmentPairs} objects displays
two {\tt ranges} columns, one for the {\it first} alignment in the pair (the
left column), and one for the {\it last} alignment in the pair (the right
column). The {\tt strand} column corresponds to the strand of the {\it first}
alignment.

<<first_last>>=
head(first(U3galp))
head(last(U3galp))
@

According to the SAM format specifications, the aligner is expected to mark
each alignment pair as {\it proper} or not (flag bit 0x2 in the SAM format).
The SAM Spec only says that a pair is {\it proper} if the {\it first} and
{\it last} alignments in the pair are ``properly aligned according to the
aligner''. So the exact criteria used for setting this flag is left to the
aligner.

We use \Rcode{isProperPair} to extract this flag from the
\Rclass{GappedAlignmentPairs} object:

<<isProperPair>>=
table(isProperPair(U3galp))
@

Even though we could do {\it overlap encodings} with the full object,
we keep only the {\it proper} pairs for our downstream analysis:

<<keep_only_proper_pairs>>=
U3galp <- U3galp[isProperPair(U3galp)]
@

For the transcript, we'll reuse the \Rcode{dm3tx} object obtained
previously.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Find and encode the overlaps}

Let's compute the overlaps:

<<U3ov>>=
U3ov <- findOverlaps(U3galp, dm3tx, ignore.strand=TRUE)
@

and encode them:

<<U3ovenc>>=
U3grl <- grglist(U3galp, order.as.in.query=TRUE)
U3ovenc <- encodeOverlaps(U3grl, dm3tx, hits=U3ov, flip.query.if.wrong.strand=TRUE)
U3ovenc
@

Unique encodings in \Rcode{U3ovenc}:

<<U3ovenc_table>>=
unique_U3ovenc <- levels(encoding(U3ovenc))
length(unique_U3ovenc)
head(unique_U3ovenc)
U3ovenc_table <- table(encoding(U3ovenc))
tail(sort(U3ovenc_table))
@


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{``Compatible'' paired-end overlaps}

\Rcode{U3ovenc} contains 13 unique encodings ``compatible'' with the splicing
of the transcript:

<<compatible_unique_U3ovenc>>=
sort(U3ovenc_table[isCompatibleWithSplicing(unique_U3ovenc)])
@

Encodings \Rcode{"1{-}{-}1:i{-}{-}i:"} (89039 occurences in \Rcode{U3ovenc}),
\Rcode{"2{-}{-}1:jm{-}{-}m:af{-}{-}i:"} (2825 occurences in \Rcode{U3ovenc}),
\Rcode{"1{-}{-}2:i{-}{-}jm:a{-}{-}af:"} (2339 occurences in \Rcode{U3ovenc}),
and \Rcode{"1{-}{-}1:i{-}{-}m:a{-}{-}i:"} (342 occurences in \Rcode{U3ovenc}),
correspond to the following overlaps:

\begin{itemize}
  \item \Rcode{"1{-}{-}1:i{-}{-}i:"}
\begin{verbatim}
  - paired-end read (no gap on the first end, no gap on the
    last end):               oooo   oooo
  - transcript:     ...   >>>>>>>>>>>>>>>>   ...
\end{verbatim}

  \item \Rcode{"2{-}{-}1:jm{-}{-}m:af{-}{-}i:"}
\begin{verbatim}
  - paired-end read (1 gap on the first end, no gap on the
    last end):                 ooo---o    oooo
  - transcript:     ...   >>>>>>>>   >>>>>>>>>>>   ...
\end{verbatim}

  \item \Rcode{"1{-}{-}2:i{-}{-}jm:a{-}{-}af:"}
\begin{verbatim}
  - paired-end read (no gap on the first end, 1 gap on the
    last end):             oooo      oo---oo
  - transcript:     ...  >>>>>>>>>>>>>>   >>>>>>>>>  ...
\end{verbatim}

  \item \Rcode{"1{-}{-}1:i{-}{-}m:a{-}{-}i:"}
\begin{verbatim}
  - paired-end read (no gap on the first end, no gap on the
    last end):               oooo      oooo
  - transcript:     ...   >>>>>>>>>   >>>>>>>   ...
\end{verbatim}
\end{itemize}

Note: switch use of ``first'' and ``last'' above if the read was flipped.

<<U3ov_is_compat>>=
U3ov_is_compat <- isCompatibleWithSplicing(U3ovenc)
table(U3ov_is_compat)  # 95801 "compatible" overlaps
@

Number of ``compatible'' overlaps per alignment pair in \Rcode{U3galp}:

<<U3galp_ncompat>>=
U3galp_ncompat <- tabulate(queryHits(U3ov)[U3ov_is_compat], nbins=length(U3galp))
elementMetadata(U3galp)$ncompat <- U3galp_ncompat
head(U3galp)
table(U3galp_ncompat)
mean(U3galp_ncompat >= 1)
@

66.8\% of the alignment pairs in \Rcode{U3galp} are ``compatible''
with at least 1 transcript in \Rcode{dm3tx}.

Number of ``compatible'' overlaps per transcript in \Rcode{dm3tx}:

<<dm3tx_U3ncompat>>=
dm3tx_U3ncompat <- tabulate(subjectHits(U3ov)[U3ov_is_compat], nbins=length(dm3tx))
names(dm3tx_U3ncompat) <- names(dm3tx)
tail(table(dm3tx_U3ncompat))
mean(dm3tx_U3ncompat >= 1)
@

Only 1\% of the transcripts in \Rcode{dm3tx} are ``compatible''
with at least 1 alignment pair in \Rcode{U3galp}.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Projecting the paired-end reads on the transcripts}

For a paired-end read, the {\it query start} is the start of its ``left end''.

<<U3ov_Lqstart>>=
U3ov_Lqstart <- extractQueryStartInTranscript(U3grl, dm3tx,
                                              hits=U3ov, ovenc=U3ovenc)
head(subset(U3ov_Lqstart, U3ov_is_compat))
@

Note that \Rfunction{extractQueryStartInTranscript} can be called with
\Rcode{for.query.right.end=TRUE} if we want this information for the ``right
ends'' of the reads:

<<U3ov_Rqstart>>=
U3ov_Rqstart <- extractQueryStartInTranscript(U3grl, dm3tx,
                                              hits=U3ov, ovenc=U3ovenc,
                                              for.query.right.end=TRUE)
head(subset(U3ov_Rqstart, U3ov_is_compat))
@

In order to perform the same kind of sanity check that we did for the
single-end reads, we need to split \Rcode{U3grl} in 2 \Rclass{GRangesList}
objects of the same length as \Rcode{U3grl}, one containing the ranges of
the ``first ends'' (aka ``first segments'' in BAM jargon), and one containing
the ranges of the ``last ends'' (aka ``last segments'' in BAM jargon).
Here is an efficient way to do this:

<<split_U3grl>>=
U3grl_first <- grglist(first(U3galp), order.as.in.query=TRUE)
U3grl_last <- grglist(last(U3galp, invert.strand=TRUE), order.as.in.query=TRUE)
@

Then we extract the sequences from the reference genome based on the ranges
in those 2 \Rclass{GRangesList} objects:

<<U3qseq_first_and_last>>=
U3qseq_first <- extractTranscriptsFromGenome(Dmelanogaster, U3grl_first)
U3qseq_last <- extractTranscriptsFromGenome(Dmelanogaster, U3grl_last)
@

and we assign 2 sequences to each overlap, one for each end of the read:

<<U3ov_Lqseq_and_Rqseq>>=
U3ov_Lqseq <- U3qseq_first[queryHits(U3ov)]
U3ov_Rqseq <- U3qseq_last[queryHits(U3ov)]
@

For the single-end reads, the sequences associated with a ``flipped query''
just needed to be ``reverse complemented''. For paired-end reads, we also
need to swap them between \Rcode{U3ov\_Lqseq} and \Rcode{U3ov\_Rqseq}:

<<U3ov_Lqseq_and_Rqseq>>=
flip_idx <- which(flippedQuery(U3ovenc))
tmp <- U3ov_Lqseq[flip_idx]
U3ov_Lqseq[flip_idx] <- reverseComplement(U3ov_Rqseq[flip_idx])
U3ov_Rqseq[flip_idx] <- reverseComplement(tmp)
@

We assign the transcript sequence to each overlap:

<<U3ov_txseq>>=
U3ov_txseq <- txseq[subjectHits(U3ov)]
@

Finally we do our sanity check of comparing the read and transcript
nucleotide sequences for each ``compatible'' overlap.
We check the ``left ends'':

<<U3ov_Lqseq_vs_U3ov_txseq>>=
stopifnot(all(
    U3ov_Lqseq[U3ov_is_compat] == narrow(U3ov_txseq[U3ov_is_compat],
                                         start=U3ov_Lqstart$startInTranscript[U3ov_is_compat],
                                         width=width(U3ov_Lqseq)[U3ov_is_compat])
))
@

and the ``right ends'':

<<U3ov_Rqseq_vs_U3ov_txseq>>=
stopifnot(all(
    U3ov_Rqseq[U3ov_is_compat] == narrow(U3ov_txseq[U3ov_is_compat],
                                         start=U3ov_Rqstart$startInTranscript[U3ov_is_compat],
                                         width=width(U3ov_Rqseq)[U3ov_is_compat])
))
@

Now let's have a look at the ``real'' read sequences. Like we did with our
single-end reads, we load them by reloading the BAM file and requesting
the SEQ field and NM tag. Since we've removed the improper pairs from
our current \Rcode{U3galp}, we need to do this again but now we do it at
load time which is equivalent to doing it afterward (i.e. not only do we
have the guarantee to end up with the same elements in \Rcode{U3galp}, but
also to have them in the same order):

<<U3bamseq_first_and_last>>=
flag2 <- scanBamFlag(isDuplicate=FALSE, isValidVendorRead=TRUE, isProperPair=TRUE)
param2 <- ScanBamParam(flag=flag2, what="seq", tag="NM")
U3galp <- readGappedAlignmentPairs(untreated3_chr4(), use.names=TRUE, param=param2)

U3bamseq_first <- elementMetadata(first(U3galp))$seq
names(U3bamseq_first) <- names(U3galp)
head(U3bamseq_first)

U3bamseq_last <- elementMetadata(last(U3galp))$seq
names(U3bamseq_last) <- names(U3galp)
head(U3bamseq_last)
@

We obtain the {\it original} sequences (i.e. the sequences stored in the
file used as input to the aligner) by ``reverse complementing'' those
that are aligned to the minus strand:

<<U3seq_first_and_last>>=
U3seq_first <- U3bamseq_first
is_on_minus <- as.logical(strand(first(U3galp)) == "-")
U3seq_first[is_on_minus] <- reverseComplement(U3seq_first[is_on_minus])

U3seq_last <- U3bamseq_last
is_on_minus <- as.logical(strand(last(U3galp)) == "-")
U3seq_last[is_on_minus] <- reverseComplement(U3seq_last[is_on_minus])
@

The following tables indicate that indels were not allowed/supported 
during the alignment process (no I or D CIGAR operations):

<<no_indels_in_U3galp>>=
colSums(cigarOpTable(cigar(first(U3galp))))
colSums(cigarOpTable(cigar(last(U3galp))))
@

So we should only see mismatches (typically a small number) between the
{\it original} sequences (in \Rcode{U3seq\_first} and \Rcode{U3seq\_last})
and those in \Rcode{U3qseq\_first} and \Rcode{U3qseq\_last}, but no indels.
We do this comparison for the first 500 sequences in \Rcode{U3galp}:

<<U3seq_vs_U3qseq>>=
U3galp_first_nedit500 <- sapply(1:500, function(i)
    neditAt(U3seq_first[[i]], U3qseq_first[[i]])
)
table(U3galp_first_nedit500)

U3galp_last_nedit500 <- sapply(1:500, function(i)
    neditAt(reverseComplement(U3seq_last[[i]]), U3qseq_last[[i]])
)
table(U3galp_last_nedit500)
@

The edit distance reported by the aligner in the NM tag should
be the same as the value returned by \Rfunction{neditAt}:

<<U3galp_nedit_vs_NM>>=
U3galp_first_nedit <- elementMetadata(first(U3galp))$NM
stopifnot(all(U3galp_first_nedit[1:500] == U3galp_first_nedit500))

U3galp_last_nedit <- elementMetadata(last(U3galp))$NM
stopifnot(all(U3galp_last_nedit[1:500] == U3galp_last_nedit500))
@

Finally, the following table tells us how many mismatches per read
were tolerated by the aligner:

<<up_to_2_mismatches_per_end>>=
table(U3galp_first_nedit, U3galp_last_nedit)
@

Up to 2 mismatches per end.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{``Almost compatible'' paired-end overlaps}

[COMING SOON...]



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{\Rcode{sessionInfo()}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

<<sessionInfo>>=
sessionInfo()
@

\end{document}
