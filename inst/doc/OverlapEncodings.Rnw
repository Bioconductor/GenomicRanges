%\VignetteIndexEntry{Overlap encodings}
%\VignetteDepends{pasillaBamSubset, GenomicRanges, Rsamtools, GenomicFeatures}
%\VignetteKeywords{sequence, sequencing, alignments}
%\VignettePackage{GenomicRanges}
\documentclass[10pt]{article}

\usepackage{times}
\usepackage{hyperref}

\usepackage[margin=0.65in]{geometry}

\newcommand{\Rfunction}[1]{{\texttt{#1}}}
\newcommand{\Robject}[1]{{\texttt{#1}}}
\newcommand{\Rpackage}[1]{{\textsf{#1}}}
\newcommand{\Rmethod}[1]{{\texttt{#1}}}
\newcommand{\Rfunarg}[1]{{\texttt{#1}}}
\newcommand{\Rclass}[1]{{\textit{#1}}}
\newcommand{\Rcode}[1]{{\texttt{#1}}}

\newcommand{\software}[1]{\textsf{#1}}
\newcommand{\R}{\software{R}}
\newcommand{\Bioconductor}{\software{Bioconductor}}

\SweaveOpts{keep.source=TRUE}

\title{Overlap encodings}
\author{Herv\'e Pag\`es}
\date{Last modified: March 2012; Compiled: \today}

\begin{document}

\maketitle

<<options,echo=FALSE>>=
options(width=100)
@
\tableofcontents



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

In the context of an RNA-seq experiment, encoding the overlaps
between 2 \Rclass{GRangesList} objects, one containing the reads (the query),
and one containing the transcripts (the subject), can be used for
detecting hits between reads and transcripts that are compatible
with the splicing of the transcript.

Various tools are provided in the \Rpackage{IRanges} and
\Rpackage{GenomicRanges} packages for dealing with overlap encodings.
In this vignette, we illustrate how to use those tools.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Example 1: With single-end reads}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Load the reads and transcripts}

We start by loading some aligned reads into a \Rclass{GappedAlignments} object.
The reads are stored in a BAM file ({\tt untreated1\_chr4.bam}) that is located
in the \Rpackage{pasillaBamSubset} data package. This file contains single-end
reads from an RNA-seq experiment and aligned against the dm3 genome (see
\Rcode{?untreated1\_chr4} in the \Rpackage{pasillaBamSubset} package for more
information about those reads):

<<untreated1_chr4>>=
library(pasillaBamSubset)
untreated1_chr4()
library(GenomicRanges)
gal4 <- readGappedAlignments(untreated1_chr4(), use.names=TRUE)
gal4
table(ngap(gal4))
@

We also need to retrieve the dm3 transcripts and their exons from UCSC,
and extract the exons grouped by transcript in a \Rclass{GRangesList}
object. IMPORTANT: The reference genome of the transcripts must be
{\bf exactly} the same as the reference genome used to align the reads
(note that this is a general rule, not only when working with overlap
encodings):

<<makeTranscriptDbFromUCSC>>=
library(GenomicFeatures)
txdb <- makeTranscriptDbFromUCSC(genome="dm3", tablename="refGene")
exbytx0 <- exonsBy(txdb, by="tx")
@

Before \Rcode{encodeOverlaps()} or related utilities can be used,
exons in transcripts located on the minus strand must be reordered by
decreasing rank:

<<sortExonsByRank>>=
exbytx <- sortExonsByRank(exbytx0, decreasing.rank.on.minus.strand=TRUE)
exbytx0[[20]]
exbytx[[20]]
@


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Find and encode the overlaps}

We are ready to compute the overlaps:

<<findOverlaps>>=
overlaps <- findOverlaps(gal4, exbytx, ignore.strand=TRUE)
@

and to encode them:

<<encodeOverlaps>>=
ovenc <- encodeOverlaps(gal4, exbytx, hits=overlaps, ignore.strand=TRUE)
ovenc
unique_ovenc <- levels(encoding(ovenc))
length(unique_ovenc)
head(unique_ovenc)
tail(sort(table(encoding(ovenc))))
@

Encodings are sort of cryptic but utilities are provided to extract
specific meaning from them. Use of these utilities is covered in the
next subsections.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Detect overlaps showing ``compatibility'' with the transcript}

We are interested in a particular type of overlap where the read
overlaps the transcript in a "compatible" way, that is, in a way
compatible with the splicing of the transcript. We call this an
overlap of type COMPATIBLE\_WITH\_SPLICING.
Use \Rcode{isCompatibleWithSplicing()} on the \Rclass{OverlapEncodings}
object to detect overlaps of type COMPATIBLE\_WITH\_SPLICING.
\Rcode{isCompatibleWithSplicing()} can also be used on the character vector
containing the unique encodings to find those of type
COMPATIBLE\_WITH\_SPLICING i.e. those corresponding to overlaps of this
type.

7 unique encodings are of type COMPATIBLE\_WITH\_SPLICING:

<<compatible_encodings_in_table>>=
table(encoding(ovenc))[isCompatibleWithSplicing(unique_ovenc)]
@

<<>>=
is_compat <- isCompatibleWithSplicing(ovenc)
table(is_compat)  # 476124 overlaps of type COMPATIBLE_WITH_SPLICING
@

For each alignment in \Rcode{gal4}, compute the number of hits (i.e.
overlaps) of type COMPATIBLE\_WITH\_SPLICING:
<<>>=
gal4_compat_nhits <- tabulate(queryHits(overlaps)[is_compat],
                              nbins=length(gal4))
table(gal4_compat_nhits)
sum(gal4_compat_nhits != 0)  # 146012 alignments with at least one hit
                             # of type COMPATIBLE_WITH_SPLICING
@

\Rcode{gal4\_compat\_nhits != 0} can be used to subset \Rcode{gal4}:

<<>>=
gal4[gal4_compat_nhits != 0]
@

For each transcript in \Rcode{exbytx} (or \Rcode{exbytx0}), compute the number
of hits of type COMPATIBLE\_WITH\_SPLICING:
<<>>=
exbytx_compat_nhits <- tabulate(subjectHits(overlaps)[is_compat],
                                nbins=length(exbytx))
names(exbytx_compat_nhits) <- names(exbytx)
table(exbytx_compat_nhits)
@



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Example 2: With paired-end reads}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Load the paired-end reads:

<<readBamGappedAlignmentPairs>>=
untreated3_chr4()
galp4 <- readBamGappedAlignmentPairs(untreated3_chr4(), use.names=TRUE)
galp4
@

Find and encode the overlaps:

<<>>=
overlaps2 <- findOverlaps(galp4, exbytx, ignore.strand=TRUE)
ovenc2 <- encodeOverlaps(galp4, exbytx, overlaps2, ignore.strand=TRUE)
ovenc2
unique_ovenc2 <- levels(encoding(ovenc2))
length(unique_ovenc2)  # 275 unique encodings
head(unique_ovenc2)
enc_table2 <- table(encoding(ovenc2))
tail(sort(enc_table2))
@

Unique encodings compatible with the splicing of the transcript:

<<>>=
tail(sort(enc_table2[isCompatibleWithSplicing(unique_ovenc2)]))
is_compat2 <- isCompatibleWithSplicing(ovenc2)
table(is_compat2)  # 175225 overlaps are compatible with the splicing
@

Nb of compatible overlaps per alignment pair in \Rcode{galp4}:

<<>>=
galp4_ncompat <- tabulate(queryHits(overlaps2)[is_compat2],
                          nbins=length(galp4))
elementMetadata(galp4)$ncompat <- galp4_ncompat
galp4

table(galp4_ncompat)
sum(galp4_ncompat != 0)  # 53315 alignment pairs with at least 1 compatible
                         # overlap
@

Nb of compatible overlaps per transcript in \Rcode{exbytx}:
<<>>=
exbytx_ncompat2 <- tabulate(subjectHits(overlaps2)[is_compat2],
                            nbins=length(exbytx))
names(exbytx_ncompat2) <- names(exbytx)
table(exbytx_ncompat2)
@



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{\Rcode{sessionInfo()}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

<<sessionInfo>>=
sessionInfo()
@

\end{document}
