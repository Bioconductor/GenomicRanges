%\VignetteIndexEntry{The GenomicRanges infrastructure. Examples with RNA-Seq data}
%\VignetteKeywords{annotation}
%\VignettePackage{GenomicFeatures}
\documentclass[11pt]{article}

\newcommand{\Rfunction}[1]{{\texttt{#1}}}
\newcommand{\Robject}[1]{{\texttt{#1}}}
\newcommand{\Rpackage}[1]{{\textit{#1}}}
\newcommand{\Rmethod}[1]{{\texttt{#1}}}
\newcommand{\Rfunarg}[1]{{\texttt{#1}}}
\newcommand{\Rclass}[1]{{\textit{#1}}}
\newcommand{\Rcode}[1]{{\texttt{#1}}}


\title{The GenomicRanges infrastructure. Examples with RNA-Seq data}
\author{Marc Carlson, Patrick Aboyoun, Herve Pages, Seth Falcon and Martin Morgan} 

\SweaveOpts{keep.source=TRUE} 

\begin{document} 

\maketitle


\section{Introduction}

The \Rpackage{GenomicRanges} package introduces the
\Rclass{GRanges}, \Rclass{GRangesList}, and \Rclass{GappedAlignments}
classes to manage range locations across genomes, which is useful in
the analysis of short read data. In the Bioconductor package hierarchy,
the \Rpackage{GenomicRanges} package sits above the \Rpackage{IRanges}
package and below the \Rpackage{Rsamtools}, \Rpackage{BSgenome},
\Rpackage{ShortRead}, \Rpackage{rtracklayer}, and
\Rpackage{GenomicFeatures} packages. Because of it's low-level position
in the hierarchy of Bioconductor sequence analysis packages, the
\Rpackage{GenomicRanges} package takes on the role of providing an
overview of how all these packages can be used together to solve some
common problems.

The \Rpackage{GenomicRanges} package is available at bioconductor.org
and can be downloaded via \Rfunction{biocLite}:

<<biocLite, eval=FALSE>>=
source("http://bioconductor.org/biocLite.R")
biocLite("GenomicRanges")
@ 
<<initialize, results=hide>>=
library(GenomicRanges)
@ 


%\section{Chip-seq analysis}
% Here is where Patrick can insert a section on chip-seq analysis. 


\section{Simple RNA-seq Analysis}

For the first example we will focus on RNA-seq analysis, but these
tools can also be applied to other kinds of short read data analysis.
It is also necessary to consider limitations imposed by BAM files and
the way that they are read in. BAM files can contain things that align
to multiple places (multi-reads) and this makes things more complex
since we don't know which things were aligned in this way. Therefore,
if these things are not filtered out beforehand by the aligner, we
will be counting some reads multiple times. Also, because alignments
consider the per base qualities of a sequence, it is also possible for
the same called sequence to be aligned onto two different places.
When we scan in the BAM file, these sequences will be read in based on
their predicted positions from the aligner. Thus, they can count as
different sequences even though they appear to be the same sequence
(based on their base pairs).

Let's begin by using the \Rpackage{Rsamtools} to retrieve some data
from a yeast experiment and load it into a \Rclass{GappedAlignments}
object. Here we will load in a single file that contains RNA-seq data
aligned from a wild type yeast experiment. This particular file only
has data from chromosome 13. While more data can be loaded, we will
limit our analysis to this subset for expediency purposes.

<<YeastData>>=
library(Rsamtools)
testFile <- system.file("bam", "isowt5_13e.bam", package="leeBamViews")
aligns <- readBamGappedAlignments(testFile)
@

At this point, we also have to consider carefully which build we have
so that we can know which annotation we need. This data is from Lee et
al (PMID 19096707), which is available in the \Rpackage{leeBamViews}
data package. This data originates from Gavin Sherlock's group at
Stanford and so naturally they designed their experiments with the SGD
genomes in mind. Therefore, it is probably reasonable to use the SGD
genome assembly data for Saccharomyces cerevisiae when looking at their
data. This data is available from UCSC and is therefore also accessible
through the \Rpackage{rtracklayer}, \Rpackage{BSGenome} and
\Rpackage{GenomicFeatures} packages.


\subsection{Getting relevant genomic annotations} 

Now that we have chosen a data source to match the data that the genes
were aligned to, we can simply get relevant annotation data to go with
it. The following code will load the \Rpackage{GenomicFeatures}
package, and then create an annotation database based on material from
the sgdGene track.

<<GetAnnoations>>=
library(GenomicFeatures)
txdb <- makeTranscriptDbFromUCSC(genome="sacCer2", tablename="sgdGene")
@ 

Then we simply have to retrieve data from the database using the
\Rfunction{exonsBy} method so that only exonic locations for each
transcript will be retrieved by setting the \Rfunarg{by} argument to
\Rcode{"tx"}.

<<exonsBy>>=
exonRanges <- exonsBy(txdb, "tx")
@

At this point, in spite of using the matching annotations for the data,
there is still a discrepancy in how the chromosomes were named from one
source to the next. In our data these all start with "Sc", whereas in
the annotations they do not. Also, numbers of the chromosomes for the
annotation are given in classic Roman numerals (as is traditional for
yeast). So let's quickly do a pair of simple substitutions to amend the
data so that it can match the annotations.

<<ammendData>>=
rname(aligns) <- sub("^Sc", "", rname(aligns))
rname(aligns) <- sub("13", "XIII", rname(aligns))
@ 


\subsection{Counting reads that overlap the annotations} 

Now we can count how many reads mapped to each transcript.  And, since
the \Robject{exonRanges} object only has ranges for exons, this use of
\Rfunction{countOverlaps} will only consider the exon space when
calculating the counts for each.
<<count>>=
counts <- countOverlaps(exonRanges, aligns)
@ 

For simplicities sake, we will now calculate the RPKM.  This is not
meant as an endorsement of any one measure over any other, it's just
being used here as an example that users will probably have
encountered before. Using the annotation object, we can also get the
number of bases representing each \Robject{exonRanges} element.  Note
that this sum also only includes bases that are represented by the
exons from each transcript.
<<numBases>>=
numBases <- sum(width(exonRanges))
geneLengthsInKB <- (numBases/1000)
@ 

And from this we could (as an example) calculate the sum of the
mappable reads and then calculate the RPKMs.
% RPKM as intrepreted from python code:
% RPKMs <- (counts/(sumMappable/1000000))/geneLengthsInKB
To do that we first would need to calculate the total number of reads
being considered by the experiment in millions of reads.
<<millionsMapped>>=
millionsMapped <- sum(counts)/1000000
@ 

Then we have to calculate the RPM by considering the number of reads
for each transcript relative to this value.
<<RPM>>=
# counted reads / total reads in millions
rpm <- counts/millionsMapped
@ 

Finally, we calculate the RPKM by adjusting each RPM measurement for
the length of the transcript in Kb.
<<RPKM>>=
# reads per million per geneLength in Kb
rpkm <- rpm/geneLengthsInKB
@ 

\subsection{Identifying and learning more about interesting transcripts} 

Now that we have calculated the RPKM, we can start to ask basic
questions about the results.  For example, which of the transcripts
had the two highest scores?  We can get this easily, because rpkm and
exonRanges will both be listed in the same order. 

<<sort>>=
sortedRPKM <- sort(rpkm)
tail(sortedRPKM)
@ 

From the above output, notice how the names of the sortedRPKM are the
same as the index of exonRanges we need to retrieve?  We can therefore
see that transcript 6678 and 6676 are also the IDs of the transcript
with the highest RPKM. So we can use the \Rmethod{transcripts}
accessor learn which gene that transcript is associated with like
this: 

<<annotate1>>=
transcripts(txdb, 
            vals=list(tx_id=c("6678","6676")), 
            columns=c("tx_id","gene_id"))
@ 

Once you know the gene id, you can use gene-centric annotation data
sources such as the org packages to learn more about it: 

<<annnotate2>>=
library(org.Sc.sgd.db)
toTable(org.Sc.sgdGENENAME[c("YMR297W","YMR295C")])
@ 




% NEXT: Compete the subsection on finding UNKNOWN transcribed regions.
% Basically, 1) use the annotations to filter out reads from the aligned
% reads object, and then 2) use chipseq tools to do pileups, and then
% apply cutoffs to find putative transcribed regions.


\subsection{Identifying reads that do NOT overlap known annotation} 

At this point you might be satisfied with calculating the amount of
known genes in your model, but what if you wanted to know about
regions that were transcribed but which were NOT found amongst the
annotated transcripts?  To look at these you would 1st want to filter
out transcripts that are known from your dataset using
\Rfunction{subsetByOverlaps}.

<<filterKnowns>>=
filtData <- subsetByOverlaps(aligns, exonRanges)
filtData
@

At this point, the filtData object only contains ranges that did not
overlap with any of the known exons from Saccharomycess cerevisiae.
It is interesting to note that in spite of having removed all known
exons, this object still contains about half of the original set of
aligned reads.  

If a coarser level of filtering is desired, you could also use the
output of \Rmethod{transcriptsBy} as the subject argument for
\Rmethod{subsetByOverlaps}.
Doing so would look like this:

<<filterKnowns2>>=
filtData2 <- subsetByOverlaps(aligns, transcriptsBy(txdb, "gene"))
filtData2
@ 

In this specific case, you can see that not many additional things
have been filtered out by the coarser filtering which indicates that
not many of these unknown aligned reads are from intronic regions.
Going forward in this example, we will use the set that has only
filtered out the exons just so that we can look at the set of reads
that is complementary to the ones we just counted..


The next step in looking for transcripts that are unknown is to see
where the reads are located on the genome.  To do that we will use a
function originally developed for chip-seq analysis.  The
\Rfunction{coverage} method.

<<coverage>>=
cov <- coverage(filtData)
@ 

Since we only have data for chromosome 13, lets subset down to that.
<<coverageSubset>>=
cov <- cov[13]
@ 

And now we can slice that data so that we only consider islands where
things are continuously 1 read deep.

<<islands>>=
islands <- slice(cov, lower=1)
@ 

Having identified those, we can then filter out just the islands where
the final width is at least 1000 bases long.

<<continous >1000>>=
transcribedRegions <- islands[width(islands)> 1000]
txr <- islands[width(islands)> 1000]
@ 

Having done that, we should then be able to go back to the BSGenome
object and retrieve the actual sequences.

% IN ADDITION to needing a simplified method here, we also need a way
% to cast back up from the simpler view to a more complex object
% represented by a GenomicRanges object. Specifically, when we have the
% view, we LOST the strand and the chromosome.  We have to either
% consider BOTH possible strands, or else get that from before.  For
% Chromosome, we have to retrieve the lost information from before

% IN FACT, we have to recover the strand and csome info. from before...  

% How best to do that???  Use findOverlaps on original data?

<<getSequence>>=
library(BSgenome.Scerevisiae.UCSC.sacCer2)
getYeastSequence = function(data){
  chr = rep("chrXIII",length(start(data[[1]])))
  starts = start(data[[1]])
  ends = end(data[[1]])
  strands = rep("+",length(start(data[[1]])))
  getSeq(Scerevisiae, names=chr, start=starts, end=ends, strand=strands)
}
DNASet <- getYeastSequence(transcribedRegions)
@ 



% The next step after here is to compare these strings to the BSgenome and see if there are homologs, and if not, to then see if they are repeated etc.?




% Some other ideas: 
% Retrieve data from the \Rclass{GenomicFeatures} object for the range of
% a transcript.

% Convert that into a \Rclass{DNAStringSet} so that we can search a
% \Rclass{BSgenome} for the sequence (allowing for lots of gaps).

% See how many other instances of that are in a genome, pull those out,
% and then use \Rpackage{GenomicFeatures} again to identify those
% homologous ranges.

% \section{Getting data into a \Rclass{GenomeRanges}  object}
% \subsection{\Rclass{GenomeRanges} Objects} 



\section{Session Information}

The version number of R and packages loaded for generating the vignette were:

<<SessionInfo, echo=FALSE>>=
sessionInfo()
@

\end{document}
