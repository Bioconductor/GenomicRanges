%\VignetteIndexEntry{The GenomicRanges infrastructure. Examples with RNA-Seq data}
%\VignetteKeywords{annotation}
%\VignettePackage{GenomicFeatures}
\documentclass[11pt]{article}

\newcommand{\Rfunction}[1]{{\texttt{#1}}}
\newcommand{\Robject}[1]{{\texttt{#1}}}
\newcommand{\Rpackage}[1]{{\textit{#1}}}
\newcommand{\Rmethod}[1]{{\texttt{#1}}}
\newcommand{\Rfunarg}[1]{{\texttt{#1}}}
\newcommand{\Rclass}[1]{{\textit{#1}}}
\newcommand{\Rcode}[1]{{\texttt{#1}}}


\title{The GenomicRanges infrastructure. Examples with RNA-Seq data}
\author{Marc Carlson, Patrick Aboyoun, Herve Pages, Seth Falcon and Martin Morgan}

\SweaveOpts{keep.source=TRUE}

\begin{document}

\maketitle


\section{Introduction}

The \Rpackage{GenomicRanges} package introduces the
\Rclass{GRanges}, \Rclass{GRangesList}, and \Rclass{GappedAlignments}
classes to manage range locations across genomes, which is useful in
the analysis of short read data. In the Bioconductor package hierarchy,
the \Rpackage{GenomicRanges} package sits above the \Rpackage{IRanges}
package and below the \Rpackage{Rsamtools}, \Rpackage{BSgenome},
\Rpackage{ShortRead}, \Rpackage{rtracklayer}, and
\Rpackage{GenomicFeatures} packages. Because of it's low-level position
in the hierarchy of Bioconductor sequence analysis packages, the
\Rpackage{GenomicRanges} package takes on the role of providing an
overview of how all these packages can be used together to solve some
common problems.

The \Rpackage{GenomicRanges} package is available at bioconductor.org
and can be downloaded via \Rfunction{biocLite}:

<<biocLite, eval=FALSE>>=
source("http://bioconductor.org/biocLite.R")
biocLite("GenomicRanges")
@
<<initialize, results=hide>>=
library(GenomicRanges)
@


\section{Simple RNA-seq Analysis}

For the first example we will focus on RNA-seq analysis, but these
tools can also be applied to other kinds of short read data analysis.
It is also necessary to consider limitations imposed by BAM files and
the way that they are read in. BAM files can contain things that align
to multiple places (multi-reads) and this makes things more complex
since we don't know which things were aligned in this way. Therefore,
if these things are not filtered out beforehand by the aligner, we
will be counting some reads multiple times. Also, because alignments
consider the per base qualities of a sequence, it is also possible for
the same called sequence to be aligned onto two different places.
When we scan in the BAM file, these sequences will be read in based on
their predicted positions from the aligner. Thus, they can count as
different sequences even though they appear to be the same sequence
(based on their base pairs).

Let's begin by using the \Rpackage{Rsamtools} to retrieve some data
from a yeast experiment and load it into a \Rclass{GappedAlignments}
object. Here we will load in a single file that contains RNA-seq data
aligned from a wild type yeast experiment. This particular file only
has data from chromosome 13. While more data can be loaded, we will
limit our analysis to this subset for expediency purposes.

<<YeastData>>=
library(Rsamtools)
testFile <- system.file("bam", "isowt5_13e.bam", package="leeBamViews")
aligns <- readBamGappedAlignments(testFile)
@

At this point, we also have to consider carefully which build we have
so that we can know which annotation we need. This data is from Lee et
al (PMID 19096707), which is available in the \Rpackage{leeBamViews}
data package. This data originates from Gavin Sherlock's group at
Stanford and so naturally they designed their experiments with the SGD
genomes in mind. Therefore, it is probably reasonable to use the SGD
genome assembly data for Saccharomyces cerevisiae when looking at their
data. This data is available from UCSC and is therefore also accessible
through the \Rpackage{rtracklayer}, \Rpackage{BSGenome} and
\Rpackage{GenomicFeatures} packages.

Now that we have chosen a data source to match the data that the genes
were aligned to, we can simply get relevant annotation data to go with
it. The following code will load the \Rpackage{GenomicFeatures}
package, and then create an annotation database based on material from
the sgdGene track.

<<GetAnnoations>>=
library(GenomicFeatures)
txdb <- makeTranscriptDbFromUCSC(genome="sacCer2", tablename="sgdGene")
@ 

Then we simply have to retrieve data from the database using the
\Rfunction{exonsBy} method so that only exonic locations for each
transcript will be retrieved by setting the \Rfunarg{by} argument to
\Rcode{"tx"}.

<<exonsBy>>=
exonRanges <- exonsBy(txdb, "tx")
@

At this point, in spite of using the matching annotations for the data,
there is still a discrepancy in how the chromosomes were named from one
source to the next. In our data these all start with "Sc", whereas in
the annotations they do not. Also, numbers of the chromosomes for the
annotation are given in classic Roman numerals (as is traditional for
yeast). So let's quickly do a pair of simple substitutions to amend the
data so that it can match the annotations.

<<ammendData>>=
rname(aligns) <- sub("^Sc", "", rname(aligns))
rname(aligns) <- sub("13", "XIII", rname(aligns))
@ 

Now we can count how many for each transcript, but since the
\Robject{exonRanges} object only has ranges for exons, this use of
\Rfunction{countOverlaps} will only consider the exon space when
calculating the counts for each.
<<count>>=
counts <- countOverlaps(exonRanges, aligns)
@ 

Using the annotation object, we can also get the number of bases
representing each \Robject{exonRanges} element.  Note that this sum also
only includes bases that are represented by the exons from each
transcript.
<<numBases>>=
numBases <- sum(width(exonRanges))
geneLengthsInKB <- (numBases/1000)
@ 

And from this we could (as an example) calculate the sum of the
mappable reads and then calculate the RPKMs.
% RPKM as intrepreted from python code:
% RPKMs <- (counts/(sumMappable/1000000))/geneLengthsInKB
To do that we first would need to calculate the total number of reads
being considered by the experiment in millions of reads.
<<millionsMapped>>=
millionsMapped <- sum(counts)/1000000
@ 

Then we have to calculate the RPM by considering the number of reads
for each transcript relative to this value.
<<RPM>>=
# counted reads / total reads in millions
rpm <- counts/millionsMapped
@ 

Finally, we calculate the RPKM by adjusting each RPM measurement for
the length of the transcript in Kb.
<<RPKM>>=
# reads per million per geneLength in Kb
rpkm <- rpm/geneLengthsInKB
@ 

Now that we have calculated the RPKM, we can start to ask basic
questions about the results.  For example, which of the transcripts
had the two highest scores?  We can get this easily, because rpkm and
exonRanges will both be listed in the same order.

<<sort>>=
sortedRPKM <- sort(rpkm)
tail(sortedRPKM)
@ 

From the above output, notice how the names of the sortedRPKM are the
same as the index of exonRanges we need to retrieve?  We can therefore
see that transcript 6678 and 6676 are also the IDs of the transcript
with the highest RPKM. So we can use the \Rmethod{transcripts}
accessor learn which gene that transcript is associated with like
this:

<<annotate1>>=
transcripts(txdb, 
            vals=list(tx_id=c("6678","6676")), 
            columns=c("tx_id","gene_id"))
@ 

Once you know the gene id, you can use gene-centric annotation data
sources such as the org packages to learn more about it:

<<annnotate2>>=
library(org.Sc.sgd.db)
toTable(org.Sc.sgdGENENAME[c("YMR297W","YMR295C")])
@ 


% Some other ideas: 
% Retrieve data from the \Rclass{GenomicFeatures} object for the range of
% a transcript.

% Convert that into a \Rclass{DNAStringSet} so that we can search a
% \Rclass{BSgenome} for the sequence (allowing for lots of gaps).

% See how many other instances of that are in a genome, pull those out,
% and then use \Rpackage{GenomicFeatures} again to identify those
% homologous ranges.



\section{Getting data into a \Rclass{GenomeRanges}  object}

\subsection{\Rclass{GenomeRanges} Objects}



\section{Session Information}

The version number of R and packages loaded for generating the vignette were:

<<SessionInfo, echo=FALSE>>=
sessionInfo()
@

\end{document}
