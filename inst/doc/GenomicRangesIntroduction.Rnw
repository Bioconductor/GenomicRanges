%\VignetteIndexEntry{An Introduction to GenomicRanges}
%\VignetteDepends{Rsamtools}
%\VignetteKeywords{sequence, sequencing, alignments}
%\VignettePackage{GenomicRanges}
\documentclass[10pt]{article}

\usepackage{times}
\usepackage{hyperref}

\newcommand{\Rfunction}[1]{{\texttt{#1}}}
\newcommand{\Robject}[1]{{\texttt{#1}}}
\newcommand{\Rpackage}[1]{{\textit{#1}}}
\newcommand{\Rmethod}[1]{{\texttt{#1}}}
\newcommand{\Rfunarg}[1]{{\texttt{#1}}}
\newcommand{\Rclass}[1]{{\textit{#1}}}
\newcommand{\Rcode}[1]{{\texttt{#1}}}

\newcommand{\software}[1]{\textsf{#1}}
\newcommand{\R}{\software{R}}
\newcommand{\Bioconductor}{\software{Bioconductor}}
\newcommand{\GenomicRanges}{\Rpackage{GenomicRanges}}


\title{An Introduction to Genomic Ranges Classes}
\author{Patrick Aboyoun, Herve Pages, Marc Carlson}
\date{\today}

\begin{document}

\maketitle

<<options,echo=FALSE>>=
options(width=72)
@ 

\section{Introduction}

The \Rpackage{GenomicRanges} package is available at bioconductor.org
and can be downloaded via \Rfunction{biocLite}:

<<biocLite, eval=FALSE>>=
source("http://bioconductor.org/biocLite.R")
biocLite("GenomicRanges")
@ 
<<initialize, results=hide>>=
library(GenomicRanges)
@ 

The \Rpackage{GenomicRanges} package serves as the foundation for
representing genomic locations within the \Bioconductor project.
In the \Bioconductor package hierarchy, it sits above the 
\Rpackage{IRanges} (infrastructure) package and below the
\Rpackage{BSgenome} (infrastructure), \Rpackage{Rsamtools} (I/O),
\Rpackage{ShortRead} (I/O \& QA), \Rpackage{rtracklayer} (I/O), and
\Rpackage{GenomicFeatures} (infrastructure) packages.

This package lays a foundation for genomic analysis by introducing
three classes (\Rclass{GRanges}, \Rclass{GRangesList}, and
\Rclass{GappedAlignments}), which are used to represent single
interval range features, multiple interval range features, and gapped
alignments respectively.  This vignette focuses on these classes and
their associated methods.


\section{\Rclass{GRanges}: Single Interval Range Features}

The simplest genomic features to store in an object are those that are
uniform in character.  These can be a set of binding sites,
transcripts, or exons.  As long as the features being represented are
all basically the same kind of genomic feature it makes sense to store
them in a single object.  Such features will be defined by their
position on one or several chromosomes/contigs, strandedness, and will
always have a start and end value. A collection of such features are
represented as \Rclass{GRanges} objects in the \Bioconductor
project. These objects can be created by using the \Rfunction{GRanges}
constructor function. For example,

<<example-GRanges>>=
gr <-
  GRanges(seqnames =
          Rle(c("chr1", "chr2", "chr1", "chr3"), c(1, 3, 2, 4)),
          ranges =
          IRanges(1:10, end = 7:16, names = head(letters, 10)),
          strand =
          Rle(strand(c("-", "+", "*", "+", "-")),
              c(1, 2, 2, 3, 2)),
          score = 1:10,
          GC = seq(1, 0, length=10))
gr
@ 

\noindent
creates a \Rclass{GRanges} object with 10 single interval range
features. The output of the \Rclass{GRanges} \Rmethod{show} method
provides some insight into how this information is stored internally.
For starters, a \Rclass{GRanges} object displayed in left and right
hand parts that are separated by \Rcode{|} symbols. The genomic
coordinates (seqnames, ranges, and strand) are located on the left-hand 
side and the element metadata (annotation) columns are located on the
right, which for this example are \Rcode{score} and \Rcode{GC}.


The components of the genomic coordinates within a \Rclass{GRanges} object
can be extracted using the \Rmethod{seqnames}, \Rmethod{ranges}, and
\Rmethod{strand} accessor functions.

<<GRanges-location-accessors>>=
seqnames(gr)
ranges(gr)
strand(gr)
@ 

Stored annotations for these coordinates can be extracted as a
\Rclass{DataFrame} object using the \Rmethod{elementMetadata} or the
\Rmethod{values} accessor.

<<metadataAccess>>=
elementMetadata(gr)[,"score"]
values(gr)
@ 

Finally, the total lengths of the various sequences that the ranges
are aligned to can also be stored in the \Rclass{GRanges} object.  So
if this is data from Homo sapiens, we can set the values as:

<<setSeqLengths>>=
seqlengths(gr) <- c(249250621,243199373,198022430)
gr
@ 

Methods for \Rmethod{length} and \Rmethod{names} have also been defined.

<<names>>=
names(gr)
length(gr)
@ 


\subsection{Splitting and combining \Rclass{GRanges} objects}

\Rclass{GRanges} objects can also be split apart.

<<splitAppendGRanges>>=
sp = split(gr, c(rep(1,5),rep(2,5)))
sp
@ 

And then put back together
<<combine>>=
c(sp[[1]],sp[[2]])
append(sp[[1]],sp[[2]])
@ 


\subsection{Subsetting \Rclass{GRanges} objects}

All the usual subsetting operations are in effect for \Rclass{GRanges}
objects.

<<subset1>>=
gr[1]
gr[1:2]
@ 

And if you subset by "j" as well then you can specify which of the
elementMetadat columns you desire. Notice that in this sense, the
information about where the feature is located is almost like a label
for the elementMetadata.

<<subset2>>=
gr[2:3,1]
gr[2:3,2]
@ 

And of course you can assign into elements as well with various levels
of specificity.

<<assign>>=
singles <- split(gr)
grMod <- gr
grMod[2] <-  singles[[1]]
head(grMod)
grMod[2,1] <-  singles[[3]][,1]
head(grMod)
@ 

And you can also use a lot of other useful methods to repeat, reverse,
or select specific portions of a on \Rclass{GRanges} objects as well.

<<other>>=
rep(singles[[2]], times = 3)
rev(gr)
head(gr,n=2)
tail(gr,n=2)
window(gr, start=2,end=4)
seqselect(gr, start =c(2,7), end=c(3,9))
@ 



\subsection{Basic interval operations for \Rclass{GRanges} objects}

A lot of operations for \Rclass{GRanges} objects are derived from the
kinds of operations that work on \Rclass{IRanges} objects.

<<IRangesStuff>>=
g <- gr[1:3]
g <- append(g,singles[[10]])
start(g)
end(g)
width(g)
range(g)
@ 

Some of these methods are useful for deriving other ranges from the
ranges in the original \Rclass{GRanges} object.  One of these is
\Rmethod{flank} which can be used to recover regions flanking the
set of ranges represented by the \Rclass{GRanges} object. For example
to get a \Rclass{GRanges} object where the ranges represent the 10
bases upstream of the ranges in our example we could call:

<<flank>>=
flank(g, 10)
@ 

And if we wanted the downstream bases we would call:

<<flank2>>=
flank(g, 10, start=FALSE)
@ 


Similar to \Rmethod{flank}, there are also operations to \Rmethod{resize} and
\Rmethod{shift} our \Rclass{GRanges} object.

<<shiftAndResize>>=
shift(g,5)
resize(g,30)
@ 

The \Rmethod{reduce} will align the ranges and merge overlapping
ranges to produce a simplified set.
  
<<reduce>>=
reduce(g)
@ 

Sometimes you may be interested in the spaces or the qualities of the
spaces between the ranges represented by your \Rclass{GRanges} object.
The \Rmethod{gaps} method will help you calculate the spaces between a
reduced version of your ranges:

<<gaps>>=
gaps(g)
@ 

And sometimes you also may want to know how many quantitatively unique
fragments your ranges could possibly represent.  For this task there
is the \Rmethod{disjoin} method.

<<disjoin>>=
disjoin(g)
@ 

One of the most powerful methods for looking at \Rclass{GRanges}
objects is the \Rmethod{coverage} method. The \Rmethod{coverage}
method quantifies the degree of overlap for all the ranges in a
\Rclass{GRanges} object.

<<coverage>>=
coverage(g)
@ 



\subsection{Interval set operations for \Rclass{GRanges} objects}

There are also operations for calculating relationships between
different \Rclass{GRanges} objects. Here are a some examples for how
you can calculate the \Rmethod{union}, the \Rmethod{intersect} and
the asymmetric difference (using \Rmethod{setdiff}).

<<intervals1>>=
g2 <- head(gr,n=2)
union(g,g2)
intersect(g,g2)
setdiff(g,g2)
@

In addition, there is similar set of operations that act at the level
of the individual ranges within each \Rclass{GRanges}.  These
operations all begin with a "p".  A requirement for this set of
operations is that the number of elements in each \Rclass{GRanges}
object has to be the same, and that both of the objects have to have
the same seqnames and strand assignments throughout.

<<intervals2>>=
g3 <- g[1:2]
ranges(g3[1]) <- IRanges(start=5,end=12)
punion(g2,g3)
pintersect(g2,g3)
psetdiff(g2,g3)
@ 



\section{\Rclass{GRangesLists}: Multiple Interval Range Features}

Some important genomic features are not simple but are inherently
compound structures.  A classic example of this would be exons.  Exons
belong to and are defined by the transcripts that they are spliced
into.  When genomic features consist of multiple intervals ranges that
are grouped by a parent feature, they are represented as
\Rclass{GRangesList} object. Consider the simple example of the two
transcript \Rfunction{GRangesList} below created using the
\Rfunction{GRangesList} constructor.

<<example-GRangesList>>=
gr1 <-
  GRanges(seqnames = "chr2", ranges = IRanges(3, 6),
          strand = "+", score = 5L, GC = 0.45)
gr2 <-
  GRanges(seqnames = c("chr1", "chr1"),
          ranges = IRanges(c(7,13), width = 3),
          strand = c("+", "-"), score = 3:4, GC = c(0.3, 0.5))
grl <- GRangesList("txA" = gr1, "txB" = gr2)
grl
@ 

The \Rmethod{show} method for a \Rclass{GRangesList} object displays
it as a list of \Rclass{GRanges} objects.



\subsection{Basic \Rclass{GRangesList} accessors}

Just as with \Rclass{GRanges} object, the components of the genomic
coordinates within a \Rclass{GRangesList} object can be extracted
using simple accessor methods. Not surprisingly, the
\Rclass{GRangesList} objects have many of the same accessors a
\Rclass{GRanges} objects.  The difference is that most of these
methods have to return a list since the input is now essentially a
list of \Rclass{GRanges} objects. Here are a few examples:

<<basicGRLAccessors>>=
seqnames(grl)
ranges(grl)
strand(grl)
@

Some of the methods do not return a list however.  The
\Rmethod{length} and \Rmethod{names} methods will return the length or
names of the list that was input rather than of the individual
\Rclass{GRanges} objects.  And, the \Rmethod{seqengths} method will
only return one set of sequence lengths, since these are shared by all
the \Rclass{GRangesList} elements.

<<exceptions>>=
length(grl)
names(grl)
seqlengths(grl)
@ 

The \Rmethod{elementLengths} method returns a list of integers
corresponding to the result of calling \Rmethod{length} on each
individual \Rclass{GRanges} object contained by the
\Rclass{GRangesList}.  This is really a shortcut to avoid calling
\Rmethod{apply} on the \Rclass{GRangesList}.

<<elementLengths>>=
elementLengths(grl)
@ 

You can also use \Rmethod{isEmpty} to test if a \Rclass{GRangesList}
object contains anything.

<<isEmpty>>=
isEmpty(grl)
@ 


%% The following two things don't seem to work yet???
%      \code{elementMetadata(x)}, \code{elementMetadata(x) <- value}:
%      \code{values(x), values(x) <- value}:







\subsection{Combining \Rclass{GRangesList} objects}

\Rclass{GRangesList} objects can be unlisted to combine the separate
\Rclass{GRanges} objects that they contain as an expanded
\Rclass{GRanges}.

<<unlistGRL>>=
ul <- unlist(grl)
@ 

%% These two don't seem to exist yet??
%      \code{append(x, values, after = length(x))}:
%      \code{c(x, ...)}:



\subsection{Basic interval operations for \Rclass{GRangesList} objects}

For interval operations, many of the same methods exist for
\Rclass{GRangesList} objects as exist for \Rclass{GRanges} objects,
and they behave similarly as well.  The only difference is that in
this case, the operation will be applied to every element of every
\Rclass{GRanges} object in the \Rclass{GRangesList}, and the result
being another list object.

<<intOpsGRL>>=
start(grl)
end(grl)
width(grl)
@ 


And as with \Rclass{GRanges} objects, you can also shift all the
\Rclass{GRanges} objects in a \Rclass{GRangesList} object, or
calculate the coverage.  Both of these operations are also carried out
across each \Rclass{GRanges} list member.

<<coverageGRL>>=
shift(grl, 20)
coverage(grl)
@ 





\subsection{Subsetting \Rclass{GRangesList} objects}

As you might guess, the subsetting of a \Rclass{GRangesList} object is
quite different from subsetting on a \Rclass{GRanges} object in that
it acts as if you are subseting a list.

<<subsetGRL>>=
grl[1]
grl[[1]]
grl["txA"]
grl$txB
@ 

But in addition to this, when subsetting a \Rclass{GRangesList}, you
can also pass in another parameter (as with a \Rclass{GRanges} object)
to specify which of the elementMetadata columns you wish to select.

<<subsetGRL2>>=
grl[1,"score"]
grl["txB","GC"]
@  

The \Rmethod{head}, \Rmethod{tail}, \Rmethod{rep}, \Rmethod{rev},
\Rmethod{window} and \Rmethod{seqselect} methods all behave as you would
expect them to for a list object.  You will probably notice, for example how
the elements referred to by \Rmethod{window} or \Rmethod{seqselect} are now
list elements instead of \Rclass{GRanges} elements.

<<otherSubsetGRL>>=
rep(grl[[1]], times = 3)
rev(grl)
head(grl,n=1)
tail(grl,n=1)
window(grl, start=1,end=1)
seqselect(grl,start=2, end=2)
@ 



\subsection{Looping over \Rclass{GRangesList} objects}

For \Rclass{GRangesList} objects there is also a family of
\Rmethod{apply} methods.  These include \Rmethod{endoapply},
\Rmethod{lapply}, \Rmethod{Map}, \Rmethod{mapply},
\Rmethod{mendoapply}, \Rmethod{Reduce}, and \Rmethod{sapply} .


%      \code{endoapply(X, FUN, ...)}:
%      \code{lapply(X, FUN, ...)}:
%      \code{Map(f, ...)}:
%      \code{mapply(FUN, ..., MoreArgs = NULL, SIMPLIFY = TRUE, USE.NAMES = TRUE)}:
%      \code{mendoapply(FUN, ..., MoreArgs = NULL)}:
%      \code{Reduce(f, x, init, right = FALSE, accumulate = FALSE)}:
%      \code{sapply(X, FUN, ..., simplify=TRUE, USE.NAMES=TRUE)}:

For more information on the \Rcode{GRanges} and \Rcode{GRangesList}
classes be sure to consult their respective man pages.

<<manPage, eval=FALSE>>=
?GRanges
?GRangesList
@ 


\section{Interval overlaps involving \Rclass{GRanges} and \Rclass{GRangesLists} objects}

 %  findOverlaps(query, subject, maxgap = 0L, minoverlap = 1L,
 %               type = c("any", "start", "end"), select = c("all", "first"))
 %  countOverlaps(query, subject, maxgap = 0L, minoverlap = 1L,
 %                type = c("any", "start", "end"))
 %  subsetByOverlaps(query, subject, maxgap = 0L, minoverlap = 1L,
 %                   type = c("any", "start", "end"))
%  match(x, table, nomatch = NA_integer_, incomparables = NULL)
%  x \%in\% table 

Interval overlapping is perhaps the most common operation performed
on \Rclass{GRanges} and \Rclass{GRangesList} objects. To this end,
the \Rpackage{GenomicRanges} package provide a family of interval
overlap function. The most general of these functions is
\Rfunction{findOverlaps}, which takes a query and a subject as inputs
and returns an \Rclass{RangesMatching} object containing the index
pairings for the overlapping elements.

<<findOverlaps>>=
mtch <- findOverlaps(gr, grl)
matchMatrix(mtch)
@ 

\noindent
As suggested in the sections discussing the nature of the
\Rclass{GRanges} and \Rclass{GRangesList} classes, the index in the
\Robject{matchMatrix} for a \Rclass{GRanges} object is a single range
while for a \Rclass{GRangesList} object it is the set of ranges that
define a ``feature".

Another function in the overlaps family is \Rfunction{countOverlaps},
which tabulates the number of overlaps for each element in the query.

<<countOL>>=
countOverlaps(gr, grl)
@ 

A third function in this family is \Rfunction{subsetByOverlaps},
which extracts the elements in the query that overlap at least one
element in the subject.

<<subsetByOverlaps>>=
subsetByOverlaps(gr,grl)
@ 




\section{Gapped Alignments} 

In addition to \Rclass{GRanges} and \Rclass{GRangesList} classes, the
\GenomicRanges{} package defines the \Rclass{GappedAlignments} class,
which is a more specialized container for storing a set of alignments.
The class is intended to support alignments in general, not only
those coming from a `BAM' file. Also alignments with gaps in the
reference sequence (a.k.a. \emph{gapped alignments}) are supported
which, for example, makes the class suited for storing junction reads
from an RNA-seq experiment.

More precisely, a \Rclass{GappedAlignments} object is a vector-like
object where each element describes an \emph{alignment}, that is,
how a given sequence (called \emph{query} or \emph{read}, typically
short) aligns to a reference sequence (typically long).

As shown later in this document, a \Rclass{GappedAlignments} object
can be created from a `BAM' file. In that case, each element in the
resulting object will correspond to a record in the file.
One important thing to note though is that not all the information
present in the BAM/SAM records is stored in the object. In particular,
for now, we discard the query sequences (SEQ field), the query ids
(QNAME field), the query qualities (QUAL), the mapping qualities (MAPQ)
and any other information that is not needed in order to support the
basic set of operations described in this document.
This also means that multi-reads (i.e. reads with multiple hits in the
reference) don't receive any special treatment i.e. the various SAM/BAM
records corresponding to a multi-read will show up in the GappedAlignments
object as if they were coming from different/unrelated queries.
Also paired-end reads will be treated as single-end reads and the
pairing information will be lost. This might change in the future.


\subsection{Load a `BAM' file into a \Rclass{GappedAlignments} object}

First we use the \Rfunction{readGappedAlignments} function to load
a toy `BAM' file into a \Rclass{GappedAlignments} object:
<<readGappedAlignments>>=
library(Rsamtools)
aln1_file <- system.file("extdata", "ex1.bam", package="Rsamtools")
aln1 <- readGappedAlignments(aln1_file)
aln1
length(aln1)
@ 

3271 `BAM' records were loaded into the object.

Note that \Rfunction{readGappedAlignments} would have discarded
any `BAM' record describing an unaligned query or a query that is
a PCR or optical duplicate (see description of the <flag> field
in the SAM Format Specification
\footnote{\url{http://samtools.sourceforge.net/SAM1.pdf}}
for more information).
The reader interested in tracking down these events can always
use the \Rfunction{scanBam} function but this goes beyond the scope
of this document.

\subsection{Simple accessor methods}

There is one accessor per field displayed by the \Rmethod{show} method
and it has the same name as the field. All of them return a vector or
factor of the same length as the object:
<<accessors>>=
head(rname(aln1))
levels(rname(aln1))
head(strand(aln1))
head(cigar(aln1))
head(qwidth(aln1))
head(start(aln1))
head(end(aln1))
head(width(aln1))
head(ngap(aln1))
@

\subsection{More accessor methods}



\end{document}
