%\VignetteIndexEntry{An Introduction to GenomicRanges}
%\VignetteDepends{Rsamtools}
%\VignetteKeywords{sequence, sequencing, alignments}
%\VignettePackage{GenomicRanges}
\documentclass[10pt]{article}

\usepackage{times}
\usepackage{hyperref}

\newcommand{\Rfunction}[1]{{\texttt{#1}}}
\newcommand{\Robject}[1]{{\texttt{#1}}}
\newcommand{\Rpackage}[1]{{\textit{#1}}}
\newcommand{\Rmethod}[1]{{\texttt{#1}}}
\newcommand{\Rfunarg}[1]{{\texttt{#1}}}
\newcommand{\Rclass}[1]{{\textit{#1}}}
\newcommand{\Rcode}[1]{{\texttt{#1}}}

\newcommand{\software}[1]{\textsf{#1}}
\newcommand{\R}{\software{R}}
\newcommand{\Bioconductor}{\software{Bioconductor}}
\newcommand{\GenomicRanges}{\Rpackage{GenomicRanges}}


\title{An Introduction to Genomic Ranges Classes}
\author{Patrick Aboyoun, Herve Pages, Marc Carlson}
\date{\today}

\begin{document}

\maketitle

<<options,echo=FALSE>>=
options(width=72)
@ 

\section{Introduction}

The \Rpackage{GenomicRanges} package is available at bioconductor.org
and can be downloaded via \Rfunction{biocLite}:

<<biocLite, eval=FALSE>>=
source("http://bioconductor.org/biocLite.R")
biocLite("GenomicRanges")
@ 
<<initialize, results=hide>>=
library(GenomicRanges)
@ 

The \Rpackage{GenomicRanges} package serves as the foundation for
representing genomic locations within the \Bioconductor project.
In the \Bioconductor package hierarchy, it sits above the 
\Rpackage{IRanges} (infrastructure) package and below the
\Rpackage{BSgenome} (infrastructure), \Rpackage{Rsamtools} (I/O),
\Rpackage{ShortRead} (I/O \& QA), \Rpackage{rtracklayer} (I/O), and
\Rpackage{GenomicFeatures} (infrastructure) packages.

This package lays the foundation by introducing three classes
(\Rclass{GRanges}, \Rclass{GRangesList}, and \Rclass{GappedAlignments}),
which are used to represent single interval range features,
multiple interval range features, and gapped alignments respectively.
This vignette focuses on these classes and their associated methods.


\section{\Rclass{GRanges}: Single Interval Range Features}

The simplest genomic feature are those that lie on a single
chromosome/contig, on one or both strands of the DNA, and
have a start and end value. The collection of these features are
represented as \Rclass{GRanges} objects in the \Bioconductor
project. These objects can be created by using the \Rfunction{GRanges}
constructor function. For example,

<<example-GRanges>>=
gr <-
  GRanges(seqnames =
          Rle(c("chr1", "chr2", "chr1", "chr3"), c(1, 3, 2, 4)),
          ranges =
          IRanges(1:10, width = 10:1, names = head(letters, 10)),
          strand =
          Rle(strand(c("-", "+", "*", "+", "-")),
              c(1, 2, 2, 3, 2)),
          score = 1:10,
          GC = seq(1, 0, length=10))
gr
@ 

\noindent
creates a \Rclass{GRanges} object with 10 single interval range
features. The output of the \Rclass{GRanges} \Rmethod{show} method
provides some insight into how this information is stored internally.
For starters, a \Rclass{GRanges} object displayed in left and right
hand parts that are separated by \Rcode{|} symbols. The genomic
coordinates (seqnames, ranges, and strand) are located on the left-hand 
side and the element metadata (annotation) columns are located on the
right, which for this example are \Rcode{score} and \Rcode{GC}.

%\subsection{Basic \Rclass{GRanges} accessors}

%      \code{seqnames(x)}, \code{seqnames(x) <- value}:
%      \code{ranges(x)}, \code{ranges(x) <- value}:
%      \code{strand(x)}, \code{strand(x) <- value}:
%      \code{seqlengths(x)}, \code{seqlengths(x) <- value}:
%      \code{elementMetadata(x)}, \code{elementMetadata(x) <- value}:
%      \code{values(x), values(x) <- value}:
%      \code{names(x)}, \code{names(x) <- value}:
%      \code{length(x)}:

The components of the genomic coordinates within a \Rclass{GRanges} object
can be extracted using the \Rmethod{seqnames}, \Rmethod{ranges}, and
\Rmethod{strand} accessor functions.

<<GRanges-location-accessors>>=
seqnames(gr)
ranges(gr)
strand(gr)
@ 

The annotations for these coordinates can be extracted as a
\Rclass{DataFrame} object using the \Rmethod{elementMetadata}
accessor.

<<metadataAccess>>=
elementMetadata(gr)[,"score"]
@ 

%\subsection{Splitting and combining \Rclass{GRanges} objects}

%      \code{append(x, values, after = length(x))}:
%      \code{c(x, ...)}:
%      \code{split(x, f = seq_len(length(x)), drop = FALSE)}:

%\subsection{Subsetting \Rclass{GRanges} objects}

%      \code{x[i, j]}, \code{x[i, j] <- value}:
%      \code{x[i,j] <- value}:
%      \code{head(x, n = 6L)}:
%      \code{rep(x, times, length.out, each)}:
%      \code{rev(x)}:
%      \code{seqselect(x, start=NULL, end=NULL, width=NULL)}:
%      \code{seqselect(x, start=NULL, end=NULL, width=NULL) <- value}:
%      \code{subset(x, subset)}:
%      \code{tail(x, n = 6L)}:
%      \code{window(x, start = NA, end = NA, width = NA, frequency = NULL, delta = NULL, ...)}:
%      \code{window(x, start = NA, end = NA, width = NA, keepLength = TRUE) <- value}:

%\subsection{Basic interval operations for \Rclass{GRanges} objects}

%      \code{start(x)}, \code{start(x) <- value}:
%      \code{end(x)}, \code{end(x) <- value}:
%      \code{width(x)}, \code{width(x) <- value}:
%      \code{flank(x, width, start = TRUE, both = FALSE, use.names = TRUE)}:
%      \code{resize(x, width, use.names = TRUE)}:
%      \code{shift(x, shift, use.names = TRUE)}:
%      \code{disjoin(x)}:
%      \code{gaps(x, start=NA, end=NA)}:
%      \code{range(x, ...)}:
%      \code{reduce(x, drop.empty.ranges = FALSE, min.gapwidth = 1L)}:
%      \code{coverage(x, shift = list(0L), width = as.list(seqlengths(x)), weight = list(1L))}:


\section{\Rclass{GRangesLists}: Multiple Interval Range Features}

When genomic features consist of multiple intervals ranges, they are
represented as \Rclass{GRangesList} object within the \Bioconductor
project. A common multiple interval range feature is a post-spliced
transcript comprised of disjoint exons. These objects can be created
by using the \Rfunction{GRangesList} constructor function. For example,

<<example-GRangesList>>=
gr1 <-
  GRanges(seqnames = "chr2", ranges = IRanges(3, 6),
          strand = "+", score = 5L, GC = 0.45)
gr2 <-
  GRanges(seqnames = c("chr1", "chr1"),
          ranges = IRanges(c(7,13), width = 3),
          strand = c("+", "-"), score = 3:4, GC = c(0.3, 0.5))
grl <- GRangesList("txA" = gr1, "txB" = gr2)
grl
@

%\subsection{Basic \Rclass{GRangesList} accessors}

%      \code{seqnames(x)}, \code{seqnames(x) <- value}:
%      \code{ranges(x)}, \code{ranges(x) <- value}:
%      \code{strand(x)}, \code{strand(x) <- value}:
%      \code{seqlengths(x)}, \code{seqlengths(x) <- value}:
%      \code{elementMetadata(x)}, \code{elementMetadata(x) <- value}:
%      \code{values(x), values(x) <- value}:

%      \code{length(x)}:
%      \code{names(x)}, \code{names(x) <- value}:
%      \code{elementLengths(x)}:
%      \code{isEmpty(x)}:

The \Rmethod{show} method displays \Rclass{GRangesList} objects as a list
of \Rclass{GRanges} objects. Just as with \Rclass{GRanges} object,
the components of the genomic coordinates within a \Rclass{GRangesList}
object can be extracted using the \Rmethod{seqnames}, \Rmethod{ranges},
and \Rmethod{strand} accessor functions.

<<accessors>>=
strand(grl)
@

%\subsection{Combining \Rclass{GRangesList} objects}

%      \code{append(x, values, after = length(x))}:
%      \code{c(x, ...)}:
%      \code{unlist(x, recursive = TRUE, use.names = TRUE)}:

%\subsection{Basic interval operations for \Rclass{GRangesList} objects}

%      \code{start(x)}, \code{start(x) <- value}:
%      \code{end(x)}, \code{end(x) <- value}:
%      \code{width(x)}, \code{width(x) <- value}:
%      \code{shift(x, shift, use.names = TRUE)}:
%      \code{coverage(x, shift = list(0L), width = as.list(seqlengths(x)), weight = list(1L))}:

%\subsection{Subsetting \Rclass{GRangesList} objects}

%      \code{x[i, j]}, \code{x[i, j] <- value}:
%      \code{x[[i]]}, \code{x[[i]] <- value}:
%      \code{x$name}, \code{x$name <- value}:
%      \code{head(x, n = 6L)}:
%      \code{rep(x, times, length.out, each)}:
%      \code{rev(x)}:
%      \code{seqselect(x, start=NULL, end=NULL, width=NULL)}:
%      \code{seqselect(x, start=NULL, end=NULL, width=NULL) <- value}:
%      \code{subset(x, subset)}:
%      \code{tail(x, n = 6L)}:
%      \code{window(x, start = NA, end = NA, width = NA, frequency = NULL, delta = NULL, ...)}:
%      \code{window(x, start = NA, end = NA, width = NA, keepLength = TRUE) <- value}:

%\subsection{Looping over \Rclass{GRangesList} objects}

%      \code{endoapply(X, FUN, ...)}:
%      \code{lapply(X, FUN, ...)}:
%      \code{Map(f, ...)}:
%      \code{mapply(FUN, ..., MoreArgs = NULL, SIMPLIFY = TRUE, USE.NAMES = TRUE)}:
%      \code{mendoapply(FUN, ..., MoreArgs = NULL)}:
%      \code{Reduce(f, x, init, right = FALSE, accumulate = FALSE)}:
%      \code{sapply(X, FUN, ..., simplify=TRUE, USE.NAMES=TRUE)}:

For more information on the \Rcode{GRanges} and \Rcode{GRangesList}
classes consult their respective man pages.


\section{Interval overlaps involving \Rclass{GRanges} and \Rclass{GRangesLists} objects}

%  findOverlaps(query, subject, maxgap = 0L, minoverlap = 1L,
%               type = c("any", "start", "end"), select = c("all", "first"))
%  countOverlaps(query, subject, maxgap = 0L, minoverlap = 1L,
%                type = c("any", "start", "end"))
%  subsetByOverlaps(query, subject, maxgap = 0L, minoverlap = 1L,
%                   type = c("any", "start", "end"))
%  match(x, table, nomatch = NA_integer_, incomparables = NULL)
%  x \%in\% table

Interval overlapping is perhaps the most common operation performed
on \Rclass{GRanges} and \Rclass{GRangesList} objects. To this end,
the \Rpackage{GenomicRanges} package provide a family of interval
overlap function. The most general of these functions is
\Rfunction{findOverlaps}, which takes a query and a subject as inputs
and returns an \Rclass{RangesMatching} object containing the index
pairings for the overlapping elements.

<<findOverlaps>>=
mtch <- findOverlaps(gr, grl)
matchMatrix(mtch)
@ 

\noindent
As suggested in the sections discussing the nature of the
\Rclass{GRanges} and \Rclass{GRangesList} classes, the index in the
\Robject{matchMatrix} for a \Rclass{GRanges} object is a single range
while for a \Rclass{GRangesList} object it is the set of ranges that
define a ``feature".

Another function in the overlaps family is \Rfunction{countOverlaps},
which tabulates the number of overlaps for each element in the query.

<<countOL>>=
countOverlaps(gr, grl)
@ 

A third function in this family is \Rfunction{subsetByOverlaps},
which extracts the elements in the query that overlap at least one
element in the subject.

<<subsetByOverlaps>>=
subsetByOverlaps(gr,grl)
@ 


\section{Gapped Alignments}

In addition to \Rclass{GRanges} and \Rclass{GRangesList} classes, the
\GenomicRanges{} package defines the \Rclass{GappedAlignments} class,
which is a more specialized container for storing a set of alignments.
The class is intended to support alignments in general, not only
those coming from a `BAM' file. Also alignments with gaps in the
reference sequence (a.k.a. \emph{gapped alignments}) are supported
which, for example, makes the class suited for storing junction reads
from an RNA-seq experiment.

More precisely, a \Rclass{GappedAlignments} object is a vector-like
object where each element describes an \emph{alignment}, that is,
how a given sequence (called \emph{query} or \emph{read}, typically
short) aligns to a reference sequence (typically long).

As shown later in this document, a \Rclass{GappedAlignments} object
can be created from a `BAM' file. In that case, each element in the
resulting object will correspond to a record in the file.
One important thing to note though is that not all the information
present in the BAM/SAM records is stored in the object. In particular,
for now, we discard the query sequences (SEQ field), the query ids
(QNAME field), the query qualities (QUAL), the mapping qualities (MAPQ)
and any other information that is not needed in order to support the
basic set of operations described in this document.
This also means that multi-reads (i.e. reads with multiple hits in the
reference) don't receive any special treatment i.e. the various SAM/BAM
records corresponding to a multi-read will show up in the GappedAlignments
object as if they were coming from different/unrelated queries.
Also paired-end reads will be treated as single-end reads and the
pairing information will be lost. This might change in the future.


\subsection{Load a `BAM' file into a \Rclass{GappedAlignments} object}

First we use the \Rfunction{readGappedAlignments} function to load
a toy `BAM' file into a \Rclass{GappedAlignments} object:
<<readGappedAlignments>>=
library(Rsamtools)
aln1_file <- system.file("extdata", "ex1.bam", package="Rsamtools")
aln1 <- readGappedAlignments(aln1_file)
aln1
length(aln1)
@

3271 `BAM' records were loaded into the object.

Note that \Rfunction{readGappedAlignments} would have discarded
any `BAM' record describing an unaligned query or a query that is
a PCR or optical duplicate (see description of the <flag> field
in the SAM Format Specification
\footnote{\url{http://samtools.sourceforge.net/SAM1.pdf}}
for more information).
The reader interested in tracking down these events can always
use the \Rfunction{scanBam} function but this goes beyond the scope
of this document.

\subsection{Simple accessor methods}

There is one accessor per field displayed by the \Rmethod{show} method
and it has the same name as the field. All of them return a vector or
factor of the same length as the object:
<<accessors>>=
head(rname(aln1))
levels(rname(aln1))
head(strand(aln1))
head(cigar(aln1))
head(qwidth(aln1))
head(start(aln1))
head(end(aln1))
head(width(aln1))
head(ngap(aln1))
@

\subsection{More accessor methods}



\end{document}
