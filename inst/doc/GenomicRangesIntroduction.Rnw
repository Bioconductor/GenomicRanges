%\VignetteIndexEntry{An Introduction to GenomicRanges}
%\VignetteDepends{Rsamtools}
%\VignetteKeywords{sequence, sequencing, alignments}
%\VignettePackage{GenomicRanges}
\documentclass[10pt]{article}

\usepackage{times}
\usepackage{hyperref}

\newcommand{\Rfunction}[1]{{\texttt{#1}}}
\newcommand{\Robject}[1]{{\texttt{#1}}}
\newcommand{\Rpackage}[1]{{\textit{#1}}}
\newcommand{\Rmethod}[1]{{\texttt{#1}}}
\newcommand{\Rfunarg}[1]{{\texttt{#1}}}
\newcommand{\Rclass}[1]{{\textit{#1}}}
\newcommand{\Rcode}[1]{{\texttt{#1}}}

\newcommand{\software}[1]{\textsf{#1}}
\newcommand{\R}{\software{R}}
\newcommand{\Bioconductor}{\software{Bioconductor}}
\newcommand{\GenomicRanges}{\Rpackage{GenomicRanges}}


\title{An Introduction to Genomic Ranges Classes}
\author{Patrick Aboyoun, Herve Pages, Marc Carlson}
\date{\today}

\begin{document}

\maketitle

<<options,echo=FALSE>>=
options(width=72)
@ 

\section{Introduction}

The \Rpackage{GenomicRanges} package is available at bioconductor.org
and can be downloaded via \Rfunction{biocLite}:

<<biocLite, eval=FALSE>>=
source("http://bioconductor.org/biocLite.R")
biocLite("GenomicRanges")
@ 
<<initialize, results=hide>>=
library(GenomicRanges)
@ 

The \Rpackage{GenomicRanges} package serves as the foundation for
representing genomic locations within the \Bioconductor project.
In the \Bioconductor package hierarchy, it sits above the 
\Rpackage{IRanges} (infrastructure) package and below the
\Rpackage{BSgenome} (infrastructure), \Rpackage{Rsamtools} (I/O),
\Rpackage{ShortRead} (I/O \& QA), \Rpackage{rtracklayer} (I/O), and
\Rpackage{GenomicFeatures} (infrastructure) packages.

This package lays a foundation for genomic analysis by introducing
three classes (\Rclass{GRanges}, \Rclass{GRangesList}, and
\Rclass{GappedAlignments}), which are used to represent single
interval range features, multiple interval range features, and gapped
alignments respectively.  This vignette focuses on these classes and
their associated methods.


\section{\Rclass{GRanges}: Single Interval Range Features}

The simplest genomic features to store in an object are those that are
uniform in character.  These can be a set of binding sites,
transcripts, or exons.  As long as the features being represented are
all basically the same kind of genomic feature it makes sense to store
them in a single object.  Such features will be defined by their
position on one or several chromosomes/contigs, strandedness, and will
always have a start and end value. A collection of such features are
represented as \Rclass{GRanges} objects in the \Bioconductor
project. These objects can be created by using the \Rfunction{GRanges}
constructor function. For example,

<<example-GRanges>>=
gr <-
  GRanges(seqnames =
          Rle(c("chr1", "chr2", "chr1", "chr3"), c(1, 3, 2, 4)),
          ranges =
          IRanges(1:10, end = 7:16, names = head(letters, 10)),
          strand =
          Rle(strand(c("-", "+", "*", "+", "-")),
              c(1, 2, 2, 3, 2)),
          score = 1:10,
          GC = seq(1, 0, length=10))
gr
@ 

\noindent
creates a \Rclass{GRanges} object with 10 single interval range
features. The output of the \Rclass{GRanges} \Rmethod{show} method
provides some insight into how this information is stored internally.
For starters, a \Rclass{GRanges} object displayed in left and right
hand parts that are separated by \Rcode{|} symbols. The genomic
coordinates (seqnames, ranges, and strand) are located on the left-hand 
side and the element metadata (annotation) columns are located on the
right, which for this example are \Rcode{score} and \Rcode{GC}.

%\subsection{Basic \Rclass{GRanges} accessors}
% Question for PATRICK: 
% Do we really want to show people in the vignette how to use length()?
% Or is is sufficient to mention that these things exist?
% ALSO: we need to describe the seqlengths values that are sometimes present.
% 
%      \code{seqnames(x)}, \code{seqnames(x) <- value}:
%      \code{ranges(x)}, \code{ranges(x) <- value}:
%      \code{strand(x)}, \code{strand(x) <- value}:
%      \code{seqlengths(x)}, \code{seqlengths(x) <- value}:
%      \code{elementMetadata(x)}, \code{elementMetadata(x) <- value}:
%      \code{values(x), values(x) <- value}:
%      \code{names(x)}, \code{names(x) <- value}:
%      \code{length(x)}:

The components of the genomic coordinates within a \Rclass{GRanges} object
can be extracted using the \Rmethod{seqnames}, \Rmethod{ranges}, and
\Rmethod{strand} accessor functions.

<<GRanges-location-accessors>>=
seqnames(gr)
ranges(gr)
strand(gr)
@ 

Stored annotations for these coordinates can be extracted as a
\Rclass{DataFrame} object using the \Rmethod{elementMetadata}
accessor.

<<metadataAccess>>=
elementMetadata(gr)[,"score"]
@ 


\subsection{Splitting and combining \Rclass{GRanges} objects}

\Rclass{GRanges} objects can also be split apart.

<<splitAppendGRanges>>=
sp = split(gr, c(rep(1,5),rep(2,5)))
sp
@ 

And then put back together
<<combine>>=
c(sp[[1]],sp[[2]])
append(sp[[1]],sp[[2]])
@ 


\subsection{Subsetting \Rclass{GRanges} objects}

All the usual subsetting operations are in effect for \Rclass{GRanges}
objects.

<<subset1>>=
gr[1]
gr[1:2]
@ 

And if you subset by "j" as well then you can specify which of the
elementMetadat columns you desire. Notice that in this sense, the
information about where the feature is located is almost like a label
for the elementMetadata.

<<subset2>>=
gr[2:3,1]
gr[2:3,2]
@ 

And of course you can assign into elements as well with various levels
of specificity.

<<assign>>=
singles <- split(gr)
grMod <- gr
grMod[2] <-  singles[[1]]
head(grMod)
grMod[2,1] <-  singles[[3]][,1]
head(grMod)
@ 

And you can also use a lot of other useful methods on \Rclass{GRanges}
objects as well.

<<other>>=
rep(singles[[2]], times = 3)
rev(gr)
head(gr,n=2)
tail(gr,n=2)
window(gr, start=2,end=4)
seqselect(gr, start =c(2,7), end=c(3,9))
@ 



%      \code{x[i, j]}, \code{x[i, j] <- value}:
%      \code{x[i,j] <- value}:
%      \code{head(x, n = 6L)}:
%      \code{rep(x, times, length.out, each)}:
%      \code{rev(x)}:
%      \code{seqselect(x, start=NULL, end=NULL, width=NULL)}:
%      \code{seqselect(x, start=NULL, end=NULL, width=NULL) <- value}:
%      THIS ONE is not yet implemented
% \code{subset(x, subset)}: 
% \code{tail(x, n = 6L)}:
%      \code{window(x, start = NA, end = NA, width = NA, frequency = NULL, delta = NULL, ...)}:
%      \code{window(x, start = NA, end = NA, width = NA, keepLength = TRUE) <- value}:




\subsection{Basic interval operations for \Rclass{GRanges} objects}

A lot of operations for \Rclass{GRanges} objects are derived from the
kinds of operations that work on \Rclass{IRanges} objects.

<<IRangesStuff>>=
g <- gr[1:3]
g <- append(g,singles[[10]])
start(g)
end(g)
width(g)
range(g)
@ 

Some of these methods are useful for deriving other ranges from the
ranges in the original \Rclass{GRanges} object.  One of these is
\Rmethod{flank} which can be used to recover regions flanking the
set of ranges represented by the \Rclass{GRanges} object. For example
to get a \Rclass{GRanges} object where the ranges represent the 10
bases upstream of the ranges in our example we could call:

<<flank>>=
flank(g, 10)
@ 

And if we wanted the downstream bases we would call:

<<flank2>>=
flank(g, 10, start=FALSE)
@ 


Similar to \Rmethod{flank}, there are also operations to \Rmethod{resize} and
\Rmethod{shift} our \Rclass{GRanges} object.

<<shiftAndResize>>=
shift(g,5)
resize(g,30)
@ 

The \Rmethod{reduce} will align the ranges and merge overlapping
ranges to produce a simplified set.
  
<<reduce>>=
reduce(g)
@ 

Sometimes you may be intersted in the spaces or the qualities of the
spaces between the ranges represented by your \Rclass{GRanges} object.
The \Rmethod{gaps} method will help you calculate the spaces between a
reduced version of your ranges:

<<gaps>>=
gaps(g)
@ 

And sometimes you also may want to know how many quantitatively unique
fragments your ranges could possibly represent.  For this task there
is the \Rmethod{disjoin} method.

<<disjoin>>=
disjoin(g)
@ 


%      \code{start(x)}, \code{start(x) <- value}:
%      \code{end(x)}, \code{end(x) <- value}:
%      \code{width(x)}, \code{width(x) <- value}:
%      \code{flank(x, width, start = TRUE, both = FALSE, use.names = TRUE)}:
%      \code{resize(x, width, use.names = TRUE)}:
%      \code{shift(x, shift, use.names = TRUE)}:
%      \code{disjoin(x)}:
%      \code{gaps(x, start=NA, end=NA)}:
%      \code{range(x, ...)}:
%      \code{reduce(x, drop.empty.ranges = FALSE, min.gapwidth = 1L)}:
%      \code{coverage(x, shift = list(0L), width = as.list(seqlengths(x)), weight = list(1L))}: - do this one well, but do it LATER




\subsection{Interval set operations for \Rclass{GRanges} objects}

%      \code{union(x, y)}:
%      \code{intersect(x, y)}:
%      \code{setdiff(x, y)}:
%      \code{punion(x, y)}:
%      \code{pintersect(x, y)}:
%      \code{psetdiff(x, y)}:


\section{\Rclass{GRangesLists}: Multiple Interval Range Features}

Some important genomic features are not simple but are inherently
compound structures.  A classic example of this would be exons.  Exons
belong to and are defined by the transcripts that they are spliced
into.  When genomic features consist of multiple intervals ranges that
are grouped by a parent feature, they are represented as
\Rclass{GRangesList} object. Consider the simple example of the two
transcript \Rfunction{GRangesList} below created using the
\Rfunction{GRangesList} constructor.

<<example-GRangesList>>=
gr1 <-
  GRanges(seqnames = "chr2", ranges = IRanges(3, 6),
          strand = "+", score = 5L, GC = 0.45)
gr2 <-
  GRanges(seqnames = c("chr1", "chr1"),
          ranges = IRanges(c(7,13), width = 3),
          strand = c("+", "-"), score = 3:4, GC = c(0.3, 0.5))
grl <- GRangesList("txA" = gr1, "txB" = gr2)
grl
@

%\subsection{Basic \Rclass{GRangesList} accessors}

%      \code{seqnames(x)}, \code{seqnames(x) <- value}:
%      \code{ranges(x)}, \code{ranges(x) <- value}:
%      \code{strand(x)}, \code{strand(x) <- value}:
%      \code{seqlengths(x)}, \code{seqlengths(x) <- value}:
%      \code{elementMetadata(x)}, \code{elementMetadata(x) <- value}:
%      \code{values(x), values(x) <- value}:

%      \code{length(x)}:
%      \code{names(x)}, \code{names(x) <- value}:
%      \code{elementLengths(x)}:
%      \code{isEmpty(x)}:

The \Rmethod{show} method displays \Rclass{GRangesList} objects as a list
of \Rclass{GRanges} objects. Just as with \Rclass{GRanges} object,
the components of the genomic coordinates within a \Rclass{GRangesList}
object can be extracted using the \Rmethod{seqnames}, \Rmethod{ranges},
and \Rmethod{strand} accessor functions.

<<accessors>>=
strand(grl)
@

%\subsection{Combining \Rclass{GRangesList} objects}

%      \code{append(x, values, after = length(x))}:
%      \code{c(x, ...)}:
%      \code{unlist(x, recursive = TRUE, use.names = TRUE)}:

%\subsection{Basic interval operations for \Rclass{GRangesList} objects}

%      \code{start(x)}, \code{start(x) <- value}:
%      \code{end(x)}, \code{end(x) <- value}:
%      \code{width(x)}, \code{width(x) <- value}:
%      \code{shift(x, shift, use.names = TRUE)}:
%      \code{coverage(x, shift = list(0L), width = as.list(seqlengths(x)), weight = list(1L))}:

%\subsection{Subsetting \Rclass{GRangesList} objects}

%      \code{x[i, j]}, \code{x[i, j] <- value}:
%      \code{x[[i]]}, \code{x[[i]] <- value}:
%      \code{x$name}, \code{x$name <- value}:
%      \code{head(x, n = 6L)}:
%      \code{rep(x, times, length.out, each)}:
%      \code{rev(x)}:
%      \code{seqselect(x, start=NULL, end=NULL, width=NULL)}:
%      \code{seqselect(x, start=NULL, end=NULL, width=NULL) <- value}:
%      \code{subset(x, subset)}:
%      \code{tail(x, n = 6L)}:
%      \code{window(x, start = NA, end = NA, width = NA, frequency = NULL, delta = NULL, ...)}:
%      \code{window(x, start = NA, end = NA, width = NA, keepLength = TRUE) <- value}:

%\subsection{Looping over \Rclass{GRangesList} objects}

%      \code{endoapply(X, FUN, ...)}:
%      \code{lapply(X, FUN, ...)}:
%      \code{Map(f, ...)}:
%      \code{mapply(FUN, ..., MoreArgs = NULL, SIMPLIFY = TRUE, USE.NAMES = TRUE)}:
%      \code{mendoapply(FUN, ..., MoreArgs = NULL)}:
%      \code{Reduce(f, x, init, right = FALSE, accumulate = FALSE)}:
%      \code{sapply(X, FUN, ..., simplify=TRUE, USE.NAMES=TRUE)}:

For more information on the \Rcode{GRanges} and \Rcode{GRangesList}
classes consult their respective man pages.


\section{Interval overlaps involving \Rclass{GRanges} and \Rclass{GRangesLists} objects}

%  findOverlaps(query, subject, maxgap = 0L, minoverlap = 1L,
%               type = c("any", "start", "end"), select = c("all", "first"))
%  countOverlaps(query, subject, maxgap = 0L, minoverlap = 1L,
%                type = c("any", "start", "end"))
%  subsetByOverlaps(query, subject, maxgap = 0L, minoverlap = 1L,
%                   type = c("any", "start", "end"))
%  match(x, table, nomatch = NA_integer_, incomparables = NULL)
%  x \%in\% table 

Interval overlapping is perhaps the most common operation performed
on \Rclass{GRanges} and \Rclass{GRangesList} objects. To this end,
the \Rpackage{GenomicRanges} package provide a family of interval
overlap function. The most general of these functions is
\Rfunction{findOverlaps}, which takes a query and a subject as inputs
and returns an \Rclass{RangesMatching} object containing the index
pairings for the overlapping elements.

<<findOverlaps>>=
mtch <- findOverlaps(gr, grl)
matchMatrix(mtch)
@ 

\noindent
As suggested in the sections discussing the nature of the
\Rclass{GRanges} and \Rclass{GRangesList} classes, the index in the
\Robject{matchMatrix} for a \Rclass{GRanges} object is a single range
while for a \Rclass{GRangesList} object it is the set of ranges that
define a ``feature".

Another function in the overlaps family is \Rfunction{countOverlaps},
which tabulates the number of overlaps for each element in the query.

<<countOL>>=
countOverlaps(gr, grl)
@ 

A third function in this family is \Rfunction{subsetByOverlaps},
which extracts the elements in the query that overlap at least one
element in the subject.

<<subsetByOverlaps>>=
subsetByOverlaps(gr,grl)
@ 




\section{Gapped Alignments} 

In addition to \Rclass{GRanges} and \Rclass{GRangesList} classes, the
\GenomicRanges{} package defines the \Rclass{GappedAlignments} class,
which is a more specialized container for storing a set of alignments.
The class is intended to support alignments in general, not only
those coming from a `BAM' file. Also alignments with gaps in the
reference sequence (a.k.a. \emph{gapped alignments}) are supported
which, for example, makes the class suited for storing junction reads
from an RNA-seq experiment.

More precisely, a \Rclass{GappedAlignments} object is a vector-like
object where each element describes an \emph{alignment}, that is,
how a given sequence (called \emph{query} or \emph{read}, typically
short) aligns to a reference sequence (typically long).

As shown later in this document, a \Rclass{GappedAlignments} object
can be created from a `BAM' file. In that case, each element in the
resulting object will correspond to a record in the file.
One important thing to note though is that not all the information
present in the BAM/SAM records is stored in the object. In particular,
for now, we discard the query sequences (SEQ field), the query ids
(QNAME field), the query qualities (QUAL), the mapping qualities (MAPQ)
and any other information that is not needed in order to support the
basic set of operations described in this document.
This also means that multi-reads (i.e. reads with multiple hits in the
reference) don't receive any special treatment i.e. the various SAM/BAM
records corresponding to a multi-read will show up in the GappedAlignments
object as if they were coming from different/unrelated queries.
Also paired-end reads will be treated as single-end reads and the
pairing information will be lost. This might change in the future.


\subsection{Load a `BAM' file into a \Rclass{GappedAlignments} object}

First we use the \Rfunction{readGappedAlignments} function to load
a toy `BAM' file into a \Rclass{GappedAlignments} object:
<<readGappedAlignments>>=
library(Rsamtools)
aln1_file <- system.file("extdata", "ex1.bam", package="Rsamtools")
aln1 <- readGappedAlignments(aln1_file)
aln1
length(aln1)
@

3271 `BAM' records were loaded into the object.

Note that \Rfunction{readGappedAlignments} would have discarded
any `BAM' record describing an unaligned query or a query that is
a PCR or optical duplicate (see description of the <flag> field
in the SAM Format Specification
\footnote{\url{http://samtools.sourceforge.net/SAM1.pdf}}
for more information).
The reader interested in tracking down these events can always
use the \Rfunction{scanBam} function but this goes beyond the scope
of this document.

\subsection{Simple accessor methods}

There is one accessor per field displayed by the \Rmethod{show} method
and it has the same name as the field. All of them return a vector or
factor of the same length as the object:
<<accessors>>=
head(rname(aln1))
levels(rname(aln1))
head(strand(aln1))
head(cigar(aln1))
head(qwidth(aln1))
head(start(aln1))
head(end(aln1))
head(width(aln1))
head(ngap(aln1))
@

\subsection{More accessor methods}



\end{document}
